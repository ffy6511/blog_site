<!DOCTYPE html><html lang="zh-CN" data-astro-cid-bvzihdzo> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><meta name="generator" content="Astro v4.15.11"><!-- Font preloads --><link rel="preload" href="/fonts/atkinson-regular.woff" as="font" type="font/woff" crossorigin><link rel="preload" href="/fonts/atkinson-bold.woff" as="font" type="font/woff" crossorigin><!-- Canonical URL --><link rel="canonical" href="https://example.com/blog/ads_notes/"><!-- Primary Meta Tags --><title>ADS Notes</title><meta name="title" content="ADS Notes"><meta name="description" content="Lorem ipsum dolor sit amet"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://example.com/blog/ads_notes/"><meta property="og:title" content="ADS Notes"><meta property="og:description" content="Lorem ipsum dolor sit amet"><meta property="og:image" content="https://example.com/blog-placeholder-1.jpg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://example.com/blog/ads_notes/"><meta property="twitter:title" content="ADS Notes"><meta property="twitter:description" content="Lorem ipsum dolor sit amet"><meta property="twitter:image" content="https://example.com/blog-placeholder-1.jpg"><!-- 添加 MathJax --><link rel="stylesheet" href="/_astro/about.p0Xls8-U.css">
<style>a[data-astro-cid-eimmu3lg]{display:inline-block;text-decoration:none}a[data-astro-cid-eimmu3lg].active{font-weight:bolder;text-decoration:underline}
.bio[data-astro-cid-2jiluk5e]{padding:1.5rem;border-radius:8px;background:rgba(var(--gray-light),.1);margin:2rem 0}.bio[data-astro-cid-2jiluk5e] h2[data-astro-cid-2jiluk5e]{font-size:1.5rem;margin-bottom:1rem}.bio-content[data-astro-cid-2jiluk5e]{display:flex;gap:1rem;align-items:center}.avatar[data-astro-cid-2jiluk5e]{width:80px;height:80px;border-radius:50%;object-fit:cover}.bio-text[data-astro-cid-2jiluk5e]{flex:1}.name[data-astro-cid-2jiluk5e]{font-size:1rem;font-weight:700;margin:0;color:#373535}.description[data-astro-cid-2jiluk5e]{margin:.5rem 0 0;font-size:.95rem;line-height:1.5}@media (max-width: 720px){.bio-content[data-astro-cid-2jiluk5e]{flex-direction:column;text-align:center}}
.toc[data-astro-cid-xvrfupwn]{position:fixed;right:0;top:2rem;width:150px;max-height:80vh;overflow-y:auto;background:#fff;padding:1.5rem;border-left:1px solid #eee;border-radius:8px;box-shadow:0 2px 8px #0000001a}.toc[data-astro-cid-xvrfupwn] ul[data-astro-cid-xvrfupwn]{list-style:none;padding:0;margin:0}.toc[data-astro-cid-xvrfupwn] li[data-astro-cid-xvrfupwn]{margin-bottom:.5rem;padding-left:1rem}#toc-list[data-astro-cid-xvrfupwn] a[data-astro-cid-xvrfupwn]{color:#4a5568!important;text-decoration:none;font-size:.95rem;line-height:1.4;transition:color .2s}.toc[data-astro-cid-xvrfupwn] a[data-astro-cid-xvrfupwn]:hover{color:#2b6cb0}.toc[data-astro-cid-xvrfupwn] li[data-astro-cid-xvrfupwn].active>a[data-astro-cid-xvrfupwn]{color:#2b6cb0;font-weight:600}main[data-astro-cid-bvzihdzo]{width:calc(100% - 2em);max-width:100%;margin:0}.prose[data-astro-cid-bvzihdzo]{width:720px;max-width:calc(100% - 2em);margin:auto 300px auto auto;padding:1em;color:rgb(var(--gray-dark))}@media (max-width: 1024px){.prose[data-astro-cid-bvzihdzo]{margin:auto}}.hero-image[data-astro-cid-bvzihdzo]{width:100%}.hero-image[data-astro-cid-bvzihdzo] img[data-astro-cid-bvzihdzo]{display:block;margin:0 auto;border-radius:12px;box-shadow:var(--box-shadow)}.prose[data-astro-cid-bvzihdzo]{width:720px;max-width:calc(100% - 2em);margin:auto;padding:1em;color:rgb(var(--gray-dark))}.title[data-astro-cid-bvzihdzo]{margin-bottom:1em;padding:1em 0;text-align:center;line-height:1}.title[data-astro-cid-bvzihdzo] h1[data-astro-cid-bvzihdzo]{margin:0 0 .5em}.date[data-astro-cid-bvzihdzo]{margin-bottom:.5em;color:rgb(var(--gray))}.last-updated-on[data-astro-cid-bvzihdzo]{font-style:italic}
</style><script type="module" src="/_astro/hoisted.CQgWB0-B.js"></script></head> <body data-astro-cid-bvzihdzo> <header data-astro-cid-3ef6ksr2> <nav data-astro-cid-3ef6ksr2> <h2 data-astro-cid-3ef6ksr2><a href="/" data-astro-cid-3ef6ksr2>待抉的博客</a></h2> <div class="internal-links" data-astro-cid-3ef6ksr2> <a href="/" data-astro-cid-3ef6ksr2 data-astro-cid-eimmu3lg> Home </a>  <a href="/blog" class="active" data-astro-cid-3ef6ksr2 data-astro-cid-eimmu3lg> Blog </a>  <a href="/about" data-astro-cid-3ef6ksr2 data-astro-cid-eimmu3lg> About </a>  </div> <div class="social-links" data-astro-cid-3ef6ksr2> <button id="themeToggle" class="theme-toggle" aria-label="Toggle dark mode" data-astro-cid-x3pjskd3> <svg width="24" height="24" viewBox="0 0 24 24" class="sun" data-astro-cid-x3pjskd3> <path fill="currentColor" d="M12 18C8.68629 18 6 15.3137 6 12C6 8.68629 8.68629 6 12 6C15.3137 6 18 8.68629 18 12C18 15.3137 15.3137 18 12 18ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16ZM11 1H13V4H11V1ZM11 20H13V23H11V20ZM3.51472 4.92893L4.92893 3.51472L7.05025 5.63604L5.63604 7.05025L3.51472 4.92893ZM16.9497 18.364L18.364 16.9497L20.4853 19.0711L19.0711 20.4853L16.9497 18.364ZM19.0711 3.51472L20.4853 4.92893L18.364 7.05025L16.9497 5.63604L19.0711 3.51472ZM5.63604 16.9497L7.05025 18.364L4.92893 20.4853L3.51472 19.0711L5.63604 16.9497ZM23 11V13H20V11H23ZM4 11V13H1V11H4Z" data-astro-cid-x3pjskd3></path> </svg> <svg width="24" height="24" viewBox="0 0 24 24" class="moon" data-astro-cid-x3pjskd3> <path fill="currentColor" d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.94174 4 12Z" data-astro-cid-x3pjskd3></path> </svg> </button>   <a href="https://m.webtoo.ls/@astro" target="_blank" data-astro-cid-3ef6ksr2> <span class="sr-only" data-astro-cid-3ef6ksr2>Follow Astro on Mastodon</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" data-astro-cid-3ef6ksr2><path fill="currentColor" d="M11.19 12.195c2.016-.24 3.77-1.475 3.99-2.603.348-1.778.32-4.339.32-4.339 0-3.47-2.286-4.488-2.286-4.488C12.062.238 10.083.017 8.027 0h-.05C5.92.017 3.942.238 2.79.765c0 0-2.285 1.017-2.285 4.488l-.002.662c-.004.64-.007 1.35.011 2.091.083 3.394.626 6.74 3.78 7.57 1.454.383 2.703.463 3.709.408 1.823-.1 2.847-.647 2.847-.647l-.06-1.317s-1.303.41-2.767.36c-1.45-.05-2.98-.156-3.215-1.928a3.614 3.614 0 0 1-.033-.496s1.424.346 3.228.428c1.103.05 2.137-.064 3.188-.189zm1.613-2.47H11.13v-4.08c0-.859-.364-1.295-1.091-1.295-.804 0-1.207.517-1.207 1.541v2.233H7.168V5.89c0-1.024-.403-1.541-1.207-1.541-.727 0-1.091.436-1.091 1.296v4.079H3.197V5.522c0-.859.22-1.541.66-2.046.456-.505 1.052-.764 1.793-.764.856 0 1.504.328 1.933.983L8 4.39l.417-.695c.429-.655 1.077-.983 1.934-.983.74 0 1.336.259 1.791.764.442.505.661 1.187.661 2.046v4.203z" data-astro-cid-3ef6ksr2></path></svg> </a> <a href="https://twitter.com/astrodotbuild" target="_blank" data-astro-cid-3ef6ksr2> <span class="sr-only" data-astro-cid-3ef6ksr2>Follow Astro on Twitter</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" data-astro-cid-3ef6ksr2><path fill="currentColor" d="M5.026 15c6.038 0 9.341-5.003 9.341-9.334 0-.14 0-.282-.006-.422A6.685 6.685 0 0 0 16 3.542a6.658 6.658 0 0 1-1.889.518 3.301 3.301 0 0 0 1.447-1.817 6.533 6.533 0 0 1-2.087.793A3.286 3.286 0 0 0 7.875 6.03a9.325 9.325 0 0 1-6.767-3.429 3.289 3.289 0 0 0 1.018 4.382A3.323 3.323 0 0 1 .64 6.575v.045a3.288 3.288 0 0 0 2.632 3.218 3.203 3.203 0 0 1-.865.115 3.23 3.23 0 0 1-.614-.057 3.283 3.283 0 0 0 3.067 2.277A6.588 6.588 0 0 1 .78 13.58a6.32 6.32 0 0 1-.78-.045A9.344 9.344 0 0 0 5.026 15z" data-astro-cid-3ef6ksr2></path></svg> </a> <a href="https://github.com/withastro/astro" target="_blank" data-astro-cid-3ef6ksr2> <span class="sr-only" data-astro-cid-3ef6ksr2>Go to Astro's GitHub repo</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" data-astro-cid-3ef6ksr2><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z" data-astro-cid-3ef6ksr2></path></svg> </a> </div> </nav> </header>  <main data-astro-cid-bvzihdzo> <article data-astro-cid-bvzihdzo> <div class="hero-image" data-astro-cid-bvzihdzo>  </div> <div class="prose" data-astro-cid-bvzihdzo> <div class="title" data-astro-cid-bvzihdzo> <div class="date" data-astro-cid-bvzihdzo> <time datetime="2024-12-24T16:00:00.000Z"> Dec 25, 2024 </time>  </div> <h1 data-astro-cid-bvzihdzo>ADS Notes</h1> <hr data-astro-cid-bvzihdzo> </div>  <h1 id="tips">Tips</h1>
<h2 id="回顾">回顾</h2>
<ul>
<li>二项队列的删除；</li>
<li>分治—主方法</li>
</ul>
<hr>
<h1 id="整理">整理</h1>
<h2 id="inverted-file-index">Inverted File Index</h2>
<h3 id="concepts">Concepts</h3>
<ul>
<li>为什么我们需要倒排索引？</li>
</ul>
<ol>
<li>搜索引擎对于给出的<code>term</code>，需要返回包含该<code>term</code>的<code>document</code>；</li>
<li>通常的<code>index</code>指的是<code>doc</code>当中具体<code>term</code>的出现位置。但是我们无法直接搜索整篇<code>doc</code>，因为这样的操作时间成本太高；</li>
<li>因此，我们给每一个<code>term</code>设置倒排索引，用来记录它们各自在整体<code>doc</code>中的分布情况.</li>
</ol>
<h4 id="term-document-incidence-matrix">Term-Document Incidence Matrix</h4>
<p><img  src="/_astro/ads.DwX9jv2M_1pPNc9.webp" alt="alt text" width="1206" height="755" loading="lazy" decoding="async"></p>
<blockquote>
<ol>
<li>提取所有<code>doc</code>当中出现的所有<code>term</code>；</li>
<li>建立如图所示的矩形，用<code>1/0</code>表示该<code>term</code>是否在某个<code>doc</code>当中出现，形成各自的二进制向量；</li>
<li>如果要同时找出包含<code>A</code>,<code>B</code>两个<code>term</code>的<code>doc</code>索引，只需要将二者的向量作<code>&#x26;</code>运算；</li>
</ol>
</blockquote>
<br>
<ul>
<li><code>TDIM</code>的方式有什么不足？
<ul>
<li>可能出现较多的<code>0</code>,导致空间和时间的浪费；</li>
<li>无法指示<code>term</code>在对应<code>doc</code>当中的出现的频率以及具体的位置；</li>
</ul>
</li>
</ul>
<h4 id="compact-version-inverted-file-index">Compact Version: Inverted File Index</h4>
<p><img  src="/_astro/ads-1.B8fYSvLO_21V7nW.webp" alt="alt text" width="1993" height="951" loading="lazy" decoding="async">
根据前一个方法的不足，我们改进得到这样的倒排索引：<br>
在现在的版本，我们在<code>Posting List</code>当中记录了每个<code>term</code>的:</p>
<ol>
<li>总共出现的次数<code>time</code>（用于根据出现频率排序），如果要寻找多个<code>term</code>同时出现的<code>doc</code>，我们应该从<code>time</code>较小的<code>term</code>开始搜索，顺序检查其<code>Posting List</code>当中的<code>doc</code>是否被其他<code>term</code>所共有，这样就可以减少不必要的搜索；</li>
<li>分别出现的位置<code>Documents Words</code>: (<code>docID</code>, <code>wordPos</code>)
<blockquote>
<p><code>wordPos</code>应当为一个数组，因为一个<code>term</code>可能在同一个<code>doc</code>当中出现多次；</p>
</blockquote>
</li>
</ol>
<p>相关的概念:</p>
<blockquote>
<ol>
<li><code>Term Dictionary</code>: 记录所有出现的<code>term</code>；</li>
<li><code>Posting List</code>: 记录各个<code>term</code>的<code>times</code>以及<code>Document Words</code>.</li>
</ol>
</blockquote>
<hr>
<h4 id="index-generator">Index Generator</h4>
<p><img  src="/_astro/ads-2.nMwrCDs0_Z17hPST.webp" alt="alt text" width="1512" height="885" loading="lazy" decoding="async">
<strong>Steps:</strong></p>
<ol>
<li>读取所有的文档；</li>
<li>然后调用<code>Stop Filtter</code>对文档进行预处理，去除停用词；</li>
<li>对于选中的<code>term</code>，调用<code>vocabulary scanner</code>扫描文档；
<blockquote>
<p>如果在<code>Term Dictionary</code>中不存在该<code>term</code>，则添加到<code>Term Dictionary</code>中；</p>
</blockquote>
</li>
<li>找到<code>term</code>及其<code>Posting List</code>，向其中插入新的<code>node</code>；</li>
<li>结束之后，将倒排索引写回<code>disk</code>.</li>
</ol>
<blockquote>
<p>接下来，我们将从上述不同方面展开介绍如何设计一个<code>serach engine</code>.</p>
</blockquote>
<hr>
<h5 id="read-in">Read in</h5>
<ul>
<li><code>Stemming</code>: 将单词变为它的词干，如<code>running</code>变为<code>run</code>;</li>
<li><code>Stop Filtter</code>: 过滤掉一些无意义的词，如<code>the</code>, <code>and</code>, <code>a</code>, <code>an</code>等;</li>
</ul>
<br>
<h5 id="access-term">Access Term</h5>
<ul>
<li>solution 1: <code>Search tree</code>
<blockquote>
<p>B+ Tree, B-Tree, Tries..</p>
</blockquote>
<ul>
<li>性能较稳定，时间复杂度保持在<code>O(logN)</code>;</li>
</ul>
</li>
<li>solution 2: <code>Hash table</code>
<ul>
<li>平均查找时间复杂度为O(1)，查找非常高效;</li>
<li>但是不支持连续访问：在需要对字典序下连续访问的<code>term</code>的效率较低；</li>
</ul>
</li>
</ul>
<h5 id="deal-with-out-of-memory">Deal with out-of-memory</h5>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#E1E4E8">block_cnt </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">while</span><span style="color:#E1E4E8"> ( read a doc D){</span></span>
<span class="line"><span style="color:#F97583">    while</span><span style="color:#E1E4E8">( read a term T){</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8">( out of memory){</span></span>
<span class="line"><span style="color:#6A737D">            // 当内存满时，将内存中的索引块写入磁盘文件 </span></span>
<span class="line"><span style="color:#E1E4E8">            write </span><span style="color:#FFAB70">block_index</span><span style="color:#E1E4E8">[block_cnt] to disk;</span></span>
<span class="line"><span style="color:#E1E4E8">            block_cnt </span><span style="color:#F97583">++</span><span style="color:#E1E4E8">；</span></span>
<span class="line"><span style="color:#E1E4E8">            Free last block;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8">( </span><span style="color:#B392F0">find</span><span style="color:#E1E4E8">( dictionary, T) </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#B392F0">            insert</span><span style="color:#E1E4E8">( Dictionary, T);</span></span>
<span class="line"><span style="color:#E1E4E8">        Get T</span><span style="color:#9ECBFF">'s posting list;</span></span>
<span class="line"><span style="color:#9ECBFF">        Insert a node into T'</span><span style="color:#E1E4E8">s posting list;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"><span style="color:#6A737D">// 此时所有块都已经写入磁盘文件</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8">( i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> block_cnt; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#6A737D">    // 从磁盘文件读取并合并  </span></span>
<span class="line"><span style="color:#B392F0">    merge</span><span style="color:#E1E4E8">( inverted_index, </span><span style="color:#FFAB70">block_index</span><span style="color:#E1E4E8">[i]);</span></span>
<span class="line"></span></code></pre>
<br>
<h3 id="topics">Topics</h3>
<h5 id="distributed-indexing">Distributed indexing</h5>
<p><img  src="/_astro/ads-3.DHLKauCh_Z2d9uU6.webp" alt="alt text" width="1519" height="884" loading="lazy" decoding="async"></p>
<ul>
<li><code>Term-partitioned index</code>: each node contains some terms’ <strong>complete</strong> posting list;
<ul>
<li>when read in a <code>term</code>, first find its partition, then search its posting list;</li>
</ul>
</li>
<li><code>Document-partitioned index</code>: each node contains some documents’ inverted index;
<ul>
<li>when read in a <code>doc</code>, first find its partition, then search its inverted index;</li>
</ul>
</li>
<li><code>Hybrid index</code>: a combination of both;</li>
</ul>
<br>
<h5 id="dynamic-indexing">Dynamic indexing</h5>
<p>当文档数量增多时，继续向<code>dictionary</code>当中增加新的<code>term</code>节点的成本较高，需要引入辅助空间存储<code>new doc</code>的倒排索引；</p>
<ul>
<li><code>main Index</code>：存储先前的<code>doc</code>的倒排索引（占大部分）；</li>
<li><code>auxiliary Index</code>：存储新增的<code>doc</code>的倒排索引；</li>
</ul>
<ol>
<li>当我们<code>access</code>一个<code>term</code>时，首先在<code>main Index</code>中查找，如果没有找到，则在<code>auxiliary Index</code>中查找；</li>
<li>当<code>insert</code>1个新的<code>term</code>时，优先记录到辅助索引<code>auxiliary Index</code>中.</li>
<li>当辅助空间当中的数量达到一定阈值时，与<code>main Index</code>合并，并清空辅助索引；</li>
</ol>
<h5 id="compression">Compression</h5>
<p><img  src="/_astro/ads-4.fOK2kSTv_125JNu.webp" alt="alt text" width="1478" height="689" loading="lazy" decoding="async"></p>
<ol>
<li>一方面，将<code>dictionary</code>的<code>term</code>条目写在一个数组里，同时用另一个辅助数组记录各个<code>term</code>开始的<code>index</code>，从而压缩了<code>dictionary</code>的储存空间；</li>
<li>另一方面，为了避免<code>posting list</code>中倒排索引的大小溢出，用相邻位置的索引差来代替原来的倒排索引，使得整体的值保持在较小的范围；</li>
</ol>
<br>
<h5 id="thresholding-阈值">Thresholding 阈值</h5>
<p><strong>doc</strong>方面：计算各个<code>doc</code>的<code>weight</code>重要性并据此排序，仅处理<code>top x</code>文档</p>
<ul>
<li>disadvantage:
<ul>
<li>无法处理<code>boolean query</code>，即之前所说的利用<code>&#x26;</code>运算快速得到包含共有<code>term</code>的<code>index</code>；</li>
<li>将<code>miss</code>相关的部分文档</li>
</ul>
</li>
</ul>
<p><strong>query</strong>方面：将给出的<code>term</code>按照<code>frequency</code>增序排序，仅处理<code>top x</code>的<code>term</code></p>
<blockquote>
<p>出现频率较低的<code>term</code>具有更高的参考价值；</p>
</blockquote>
<p><img  src="/_astro/ads-5.BEUsbetb_1QWFfE.webp" alt="alt text" width="1161" height="242" loading="lazy" decoding="async">
设定一个阈值<code>x</code>,将全部的<code>term</code>排序之后，取部分的<code>term</code>进行一次搜索，然后取增量$\Delta x$再次搜索，如果两次相差不大，则完成搜索；如果相差较大，继续增大<code>x</code>.</p>
<h3 id="measure">Measure</h3>
<ol>
<li>建立倒排索引的速度： number of docs per hour</li>
<li><code>search</code>的速度：比较需要等待的延时；
<blockquote>
<p>注意到，由于<code>index</code>所用的<code>doc</code>数目可能不同，不同规模的<code>docs</code>也会影响<code>search</code>的时间。因此需要用 <em><strong>function of index size</strong></em>来比较不同的搜索引擎性能。</p>
</blockquote>
</li>
<li>Expressiveness of query language：
<ol>
<li>是否能够处理复杂的查询；</li>
</ol>
<blockquote>
<p>比如简单的<code>&#x26;</code>逻辑之外，是否支持类似于<code>apple-company</code>来搜索真实苹果的搜索？</p>
</blockquote>
<ol start="2">
<li>对于复杂<code>query</code>的处理速度；</li>
</ol>
</li>
<li>User happiness：
<ol>
<li>Data: response time &#x26; index space;</li>
<li>how relevant the answer set is.</li>
</ol>
</li>
</ol>
<h4 id="relevance">Relevance</h4>
<p><em><strong>precision</strong></em> P = R<sub>R</sub> / (R<sub>R</sub> + I<sub>R</sub>);  关注返回中的相关率<br>
<em><strong>recall</strong></em> R = R<sub>R</sub> / (R<sub>R</sub> + R<sub>N</sub>);   关注所有相关的返回比率</p>
<h2 id="binomial-queue">Binomial Queue</h2>
<h3 id="concepts-1">Concepts</h3>
<p>什么是二项队列？二项队列是一系列二项树的集合。因此首先需要认识 <strong>二项树</strong>.</p>
<ul>
<li><em><strong>binomial tree</strong></em>
<ul>
<li>满足堆的性质；</li>
<li>k阶二项树用 $B_k$ 表示；</li>
<li>$B_k$由$B_{k-1}$作为另一个$B_{k-1}$的孩子直接得到 => 二项树的根节点的孩子都是一棵二项树；</li>
<li>定义$B_0$为只含一个<code>root</code>的树；</li>
<li>进一步的性质：
<ul>
<li>$B_k$的根有<strong>k</strong>个孩子（即0~k-1阶的二项树），包含自身共2<sup>k</sup>个节点；</li>
<li>$B_k$的第d层具有$\binom{k}{d}$个节点；</li>
<li>由于二项树是N叉树，需要我们用左孩子右兄弟的方式来表示其结构.</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>左孩子-右兄弟</strong>的构造：</p>
<ol>
<li>将原树中每一个节点的第一个子节点作为自身的左子节点；</li>
<li>该节点的第一个<strong>兄弟</strong>作为自己的<strong>右子节点</strong></li>
<li>递归进行上述操作</li>
</ol>
</blockquote>
<ul>
<li><em><strong>bimonial queue</strong></em>
<ul>
<li>二项队列是二项树的集合；</li>
<li>二项队列包含任何阶数的二项树的个数为： <strong>0/1</strong>;</li>
<li>二项队列可能具有一个指向最小节点的指针<code>min</code>，也可能不存在，根据题目的意思来判断.</li>
</ul>
</li>
</ul>
<p>根据上述性质，如果二项队列的节点个数为<code>N</code>，可以将其转化为二进制的形式，对应阶数k的<code>0/1</code>表示$B_k$是否存在.</p>
<blockquote>
<p>13 = ${(1101)}_2$, 因此可以用0,2,3阶二项树来组成这个二项队列.</p>
</blockquote>
<br>
<h3 id="operations">Operations</h3>
<blockquote>
<p>均以最小堆为优先队列说明.</p>
</blockquote>
<ul>
<li>结构体：</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#E1E4E8"> Binomial_node{</span></span>
<span class="line"><span style="color:#E1E4E8">    ElementType key;</span></span>
<span class="line"><span style="color:#E1E4E8">    Binomial_node</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> left_child;</span></span>
<span class="line"><span style="color:#E1E4E8">    Binomial_node</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> right_sibling;</span></span>
<span class="line"><span style="color:#E1E4E8">}Binomial_node;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">typedef</span><span style="color:#F97583"> struct</span><span style="color:#E1E4E8"> Binomial_queue{</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> size;</span><span style="color:#6A737D"> // the number of the elements in the queue</span></span>
<span class="line"><span style="color:#E1E4E8">    Binomial_node</span><span style="color:#F97583">*</span><span style="color:#FFAB70"> trees</span><span style="color:#E1E4E8">[MaxTrees];</span></span>
<span class="line"><span style="color:#E1E4E8">}Binomial_queue;</span></span>
<span class="line"></span></code></pre>
<h4 id="find_min">Find_min</h4>
<p>由性质可知，最小节点一定是众多二项树当中的一个根节点，因此只需要找到这个根节点即可.</p>
<p>如果二项队列不存在指向最小元素的指针，则需要遍历整个二项队列，找到最小的根节点.在这个条件下，我们继续分析<code>Find_min</code>操作的时间复杂度上界：<br>
给定节点个数<code>N</code>，求遍历二项队列的时间复杂度上界。由于每次我们只需要访问二项树的根节点，所以求解时间复杂度等价于求解二项树的个数。将<code>N</code>转化为二进制的向量，其中<code>1</code>的个数就是二项树的个数。换言之，我们的求解可以继续转化为：</p>
<center> 给定N,求解最多其二进制表示下最多的`1`的个数.</center>  
<p>假设二进制表示下<code>1</code>的个数为 <strong>x</strong>, 当这些<code>1</code>均从低位向高位填充时，得到此时最小的<code>N</code>,即$2^x-1 \leq N$. 转换得到 $x \leq \log_2 N$. 因此，<code>Find_min</code>的时间复杂度上界为$O(\log N)$.</p>
<h4 id="merge">Merge</h4>
<ul>
<li>时间复杂度：在保证队列当中的二项树是 <em><strong>sort by height</strong></em> 的情况下，为$O(\log N)$；</li>
<li>实现思路：
<ul>
<li>将两个二项队列合并，相当于做二进制的加法，发生进位等价于二项树的合并，进位意味着更高阶二项树的产生；</li>
<li>因此，我们首先需要完成基本的“进位”操作，即<code>Combine_trees</code>函数，将两个二项树合并为一个.</li>
</ul>
</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#E1E4E8">Binomial_node</span><span style="color:#F97583">*</span><span style="color:#B392F0"> CombineTrees</span><span style="color:#E1E4E8">(Binomial_node</span><span style="color:#F97583">*</span><span style="color:#FFAB70"> T1</span><span style="color:#E1E4E8">, Binomial_node</span><span style="color:#F97583">*</span><span style="color:#FFAB70"> T2</span><span style="color:#E1E4E8">){</span></span>
<span class="line"><span style="color:#6A737D">    //based on the small-size heap</span></span>
<span class="line"><span style="color:#6A737D">    //compare the keys of the two trees and make sure T1 has the smaller one</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8">(T1->key </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> T2->key)</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#B392F0"> CombineTrees</span><span style="color:#E1E4E8">(T2,T1);</span></span>
<span class="line"><span style="color:#E1E4E8">    </span></span>
<span class="line"><span style="color:#6A737D">    //to avoid the lose the pointer of the left child of T1</span></span>
<span class="line"><span style="color:#E1E4E8">    T2->right_sibling </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> T1->left_child;</span></span>
<span class="line"><span style="color:#E1E4E8">    T1->left_child </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> T2;</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> T1;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre>
<blockquote>
<p>根据左孩子-右兄弟可以想象，每个<code>root</code>一定具有<code>left_child</code>且没有<code>right_sibling</code>。将同阶的二项树<code>T2</code>作为<code>T1</code>的<code>child</code>时，<code>T2</code>的<code>root</code>具有了自己兄弟，因此将<code>T2</code>的<code>right_sibling</code>指向<code>T1</code>的<code>left_child</code>，然后更新<code>T1</code>的<code>left_child</code>为<code>T2</code>.</p>
</blockquote>
<hr>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#E1E4E8">Binomial_queue</span><span style="color:#F97583">*</span><span style="color:#B392F0"> Merge</span><span style="color:#E1E4E8">(Binomial_queue</span><span style="color:#F97583">*</span><span style="color:#FFAB70"> H1</span><span style="color:#E1E4E8">, Binomial_queue</span><span style="color:#F97583">*</span><span style="color:#FFAB70"> H2</span><span style="color:#E1E4E8">){</span></span>
<span class="line"><span style="color:#E1E4E8">    Binomial_node</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> T1, </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">T2, </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">carry;</span></span>
<span class="line"><span style="color:#E1E4E8">    T1 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> T2 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> carry </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> i,j;</span></span>
<span class="line"><span style="color:#6A737D">    //avoid overflow of the trees array</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8">(H1->size </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> H2 -> size </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> MaxTrees){</span></span>
<span class="line"><span style="color:#B392F0">        printf</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"Error: the size of the merged queue is too large!</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">    H1->size </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> H2->size;</span><span style="color:#6A737D"> //update the size of the merged queue</span></span>
<span class="line"><span style="color:#6A737D">    //and focus: H1 is the final queue we get</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    //merge queues like a full adder</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8">(i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">, j </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">; j </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> H1->size; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">, j </span><span style="color:#F97583">*=</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">){</span></span>
<span class="line"><span style="color:#E1E4E8">        T1 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> H1->trees[i];</span></span>
<span class="line"><span style="color:#E1E4E8">        T2 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> H2->trees[i];</span></span>
<span class="line"><span style="color:#F97583">        switch</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">4</span><span style="color:#F97583">*!!</span><span style="color:#E1E4E8">carry </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 2</span><span style="color:#F97583">*!!</span><span style="color:#E1E4E8">T2 </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#F97583">*!!</span><span style="color:#E1E4E8">T1){</span></span>
<span class="line"><span style="color:#F97583">            case</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">:</span><span style="color:#6A737D">//000 means nothing to do</span></span>
<span class="line"><span style="color:#F97583">                break</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">            case</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">:</span><span style="color:#6A737D">//001 since T1 is from H1, we keep it and do nothing</span></span>
<span class="line"><span style="color:#F97583">                break</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">            case</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">:</span><span style="color:#6A737D">//010 means H2 has a tree which needs to be added to H1</span></span>
<span class="line"><span style="color:#E1E4E8">                H1->trees[i] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> T2;</span></span>
<span class="line"><span style="color:#E1E4E8">                H2->trees[i] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">                break</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">            case</span><span style="color:#79B8FF"> 3</span><span style="color:#E1E4E8">:</span><span style="color:#6A737D">//011 means we should combine T1 and T2</span></span>
<span class="line"><span style="color:#E1E4E8">                carry </span><span style="color:#F97583">=</span><span style="color:#B392F0"> CombineTrees</span><span style="color:#E1E4E8">(T1,T2);</span></span>
<span class="line"><span style="color:#E1E4E8">                H1->trees[i] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> H2->trees[i] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">                break</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">            case</span><span style="color:#79B8FF"> 4</span><span style="color:#E1E4E8">:</span><span style="color:#6A737D">//100 means H1 should add the carry to its current treeNode</span></span>
<span class="line"><span style="color:#E1E4E8">                H1->trees[i] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> carry;</span></span>
<span class="line"><span style="color:#E1E4E8">                carry </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">                break</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">            case</span><span style="color:#79B8FF"> 5</span><span style="color:#E1E4E8">:</span><span style="color:#6A737D">// 101 means we should combine the T1 and the carry, and then let it be the new carry</span></span>
<span class="line"><span style="color:#E1E4E8">                carry </span><span style="color:#F97583">=</span><span style="color:#B392F0"> CombineTrees</span><span style="color:#E1E4E8">(carry,T1);</span></span>
<span class="line"><span style="color:#E1E4E8">                H1->trees[i] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">                break</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">            case</span><span style="color:#79B8FF"> 6</span><span style="color:#E1E4E8">:</span><span style="color:#6A737D">//110 means we should combine the T2 and the carry, and then let it be the new carry</span></span>
<span class="line"><span style="color:#E1E4E8">                carry </span><span style="color:#F97583">=</span><span style="color:#B392F0"> CombineTrees</span><span style="color:#E1E4E8">(carry, T2);</span></span>
<span class="line"><span style="color:#E1E4E8">                H2->trees[i] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">                break</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">            case</span><span style="color:#79B8FF"> 7</span><span style="color:#E1E4E8">:</span><span style="color:#6A737D">//111 means we should keep the carry, and combine T1 and T2;</span></span>
<span class="line"><span style="color:#E1E4E8">                H1->trees[i] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> carry;</span></span>
<span class="line"><span style="color:#E1E4E8">                carry </span><span style="color:#F97583">=</span><span style="color:#B392F0"> CombineTrees</span><span style="color:#E1E4E8">(T1, T2);</span></span>
<span class="line"><span style="color:#E1E4E8">                H2->trees[i] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">                break</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> H1;</span></span>
<span class="line"><span style="color:#E1E4E8">} </span></span>
<span class="line"></span></code></pre>
<ol>
<li><code>Binomial_node*</code>类型的指针<code>T1</code>和<code>T2</code>等经过两次<code>!</code>的计算，从指针类型转化为了逻辑值，用来表示是否存在对应的二项树；</li>
<li>注意最终要得到的队列是<code>H1</code>，因此当加法器中的<code>1</code>仅来自于<code>H2</code>时，也要将其合并到<code>H1</code>当中；如果仅来自于<code>H1</code>就不需要操作；</li>
<li><code>011</code>则调用<code>Combine_trees</code>函数合并<code>T1</code>和<code>T2</code>，并将结果赋给<code>carry</code>；</li>
<li>利用<code>j</code>从<code>1</code>开始，每次执行左移一位，从而约束了执行的时间。假设<code>H1</code>最终结果的二进制是<code>1xxxx</code>，那么<code>j</code>相当于一个不断左移的指针，最后一步操作一定是<code>j</code>指向<code>H1</code>当中最左侧的<code>1</code>。然后跳出循环。这是合理的，因为不可能存在更多的二项树需要继续合并。</li>
</ol>
<hr>
<h4 id="insert">Insert</h4>
<blockquote>
<p>看作特殊的<code>merge</code>即可；</p>
</blockquote>
<ul>
<li>时间复杂度： 摊还下单次插入为 <strong>O(1)</strong>；</li>
<li>claim:</li>
</ul>
<h4 id="delete_min">Delete_min</h4>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#E1E4E8">Binomial_queue</span><span style="color:#F97583">*</span><span style="color:#B392F0"> DeleteMin</span><span style="color:#E1E4E8">(Binomial_queue</span><span style="color:#F97583">*</span><span style="color:#FFAB70"> H</span><span style="color:#E1E4E8">){</span></span>
<span class="line"><span style="color:#E1E4E8">    Binomial_queue</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> DeletedQueue;</span></span>
<span class="line"><span style="color:#E1E4E8">    Binomial_node</span><span style="color:#F97583">*</span><span style="color:#E1E4E8"> DeletedTree, </span><span style="color:#F97583">*</span><span style="color:#E1E4E8">oldRoot;</span></span>
<span class="line"><span style="color:#E1E4E8">    ElementType min_key </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> INFINITY;</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> min_tree </span><span style="color:#F97583">=</span><span style="color:#F97583"> -</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8">(H->size </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">){</span></span>
<span class="line"><span style="color:#B392F0">        printf</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"The queue is empty!</span><span style="color:#79B8FF">\n</span><span style="color:#9ECBFF">"</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    //step1:寻找最小值所在的树</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i</span><span style="color:#F97583">=</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8"> ; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> MaxTrees; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">){</span><span style="color:#6A737D"> // 注意检查是否存在tree</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8">(H->trees[i] </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> H->trees[i]->key </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> min_key){</span></span>
<span class="line"><span style="color:#E1E4E8">            min_key </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> H->trees[i]->key;</span></span>
<span class="line"><span style="color:#E1E4E8">            min_tree </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> i;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    //step2:将min_tree从H中移除，得到H’</span></span>
<span class="line"><span style="color:#E1E4E8">    DeletedTree </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> H->trees[min_tree];</span></span>
<span class="line"><span style="color:#E1E4E8">    H->trees[min_tree] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    oldRoot </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> DeletedTree;</span></span>
<span class="line"><span style="color:#E1E4E8">    DeletedTree </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> DeletedTree->left_child;</span></span>
<span class="line"><span style="color:#B392F0">    free</span><span style="color:#E1E4E8">(oldRoot);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    //初始化H''并将子树并入其中</span></span>
<span class="line"><span style="color:#E1E4E8">    DeletedQueue->size </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">1</span><span style="color:#F97583">&#x3C;&#x3C;</span><span style="color:#E1E4E8">min_tree) </span><span style="color:#F97583">-</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span><span style="color:#6A737D">//利用阶数计算size</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> j </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> min_tree</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; j</span><span style="color:#F97583">>=</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">;  j</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">){</span></span>
<span class="line"><span style="color:#E1E4E8">        DeletedQueue->trees[j] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> DeletedTree;</span></span>
<span class="line"><span style="color:#E1E4E8">        DeletedTree </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> DeletedTree->right_sibling;</span></span>
<span class="line"><span style="color:#E1E4E8">        DeletedQueue->trees[j]->right_sibling </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> NULL</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">    H->size </span><span style="color:#F97583">-=</span><span style="color:#E1E4E8"> DeletedQueue->size </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    H </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Merge</span><span style="color:#E1E4E8">(H, DeletedQueue);</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> H;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre>
<ol>
<li>由于k阶的二项树除去其root之后，得到了0~k-1阶的二项树的集合，我们将其看作新产生的二项队列<code>DeletedQueue</code>（需要初始化），以便于之后直接调用<code>Merge</code>函数合并到原队列<code>H</code>中；</li>
<li>最后循环构建得到<code>DeletedQueue</code>的循环需要特别注意；</li>
<li>由于<code>merge</code>中包含了<code>size</code>的更新，因此需要先将<code>H</code>的<code>size</code>减去<code>DeletedQueue</code>的<code>size</code>再加<code>1</code>；</li>
</ol>
<h3 id="analysis">Analysis</h3>
<p><strong>claim</strong>： A binomial queue of N elements can be built by Nsuccessive insertions in <strong>O(N)</strong> time.
<br></p>
<p>聚合法证明：</p>
<ul>
<li>每次插入需要构建新的<code>node</code> --- cost = 1;</li>
<li>每隔4,8,16…次插入，分别需要1,2,3…进位；</li>
<li>由于插入N次，将上述的进位代价平均到每次的插入当中，得到：</li>
</ul>
<center>N($\frac{1}{4}+\frac{1}{8}*2+\frac{1}{16}*3+\cdots+\frac{1}{2^{k+1}}*k$) = N , when k->$\infty$ </center>
<blockquote>
<p>因此，整体的时间复杂度为 O(N), 除以N得到单次插入的摊还复杂度：<strong>O(1)</strong>.</p>
</blockquote>
<br>
<p>势能法证明：</p>
<p>Let:</p>
<ul>
<li>$C_i$ := cost of the $i_{th}$ insertion</li>
<li>$Φ_i$ := number of trees after the $i$th insertion $(Φ_0 = 0)$</li>
</ul>
<p>For each insertion $i = 1, 2, …, N$:</p>
<ul>
<li>Actual cost $(C_i)$ plus change in potential $(Φ_i - Φ_{i-1})$ = 2</li>
<li>$C_i + (Φ_i - Φ_{i-1}) = 2$</li>
</ul>
<p>Sum up all N equations:
$\sum_{i=1}^N C_i + Φ_N - Φ_0 = 2N$</p>
<p>Therefore:
$\sum_{i=1}^N C_i = 2N - Φ_N ≤ 2N = O(N)$</p>
<p>While $T_{worst} = O(\log N)$, the amortized time $T_{amortized} = 2$</p>
<hr>
<h2 id="backtracking">Backtracking</h2>
<p>回溯类问题的函数模板：</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">bool</span><span style="color:#B392F0"> Backtracking</span><span style="color:#E1E4E8"> ( </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> i</span><span style="color:#E1E4E8">){</span></span>
<span class="line"><span style="color:#E1E4E8">    Found </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8">( i </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> N)</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8">(each xi in Si){</span></span>
<span class="line"><span style="color:#6A737D">        //check if satisfies the constraint</span></span>
<span class="line"><span style="color:#E1E4E8">        OK </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Check</span><span style="color:#E1E4E8">(...,R);</span><span style="color:#6A737D"> //prunning </span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8">(OK){</span></span>
<span class="line"><span style="color:#E1E4E8">            Count xi in;</span></span>
<span class="line"><span style="color:#E1E4E8">            Found </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Backtracking</span><span style="color:#E1E4E8">(i</span><span style="color:#F97583">+</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">);</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">Found)</span></span>
<span class="line"><span style="color:#B392F0">                Undo</span><span style="color:#E1E4E8">(i)l</span><span style="color:#6A737D"> //recover </span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8">(Found) </span><span style="color:#F97583">break</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> Found;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre>
<h3 id="回溯类典型问题">回溯类典型问题</h3>
<h4 id="八皇后问题">八皇后问题</h4>
<ul>
<li>约束条件：
<ul>
<li>可选集合Si = {1,2,..N};</li>
<li>(xi - xj)/(i-j) $\neq$ $\pm1$</li>
</ul>
</li>
</ul>
<h4 id="收费站问题">收费站问题</h4>
<blockquote>
<p>The Turnpike Reconstruction Problem
<img  src="/_astro/ads-6.-dM9bUo9_Z1SsJQ5.webp" alt="alt text" width="1519" height="974" loading="lazy" decoding="async"></p>
</blockquote>
<ol>
<li>初始化$x_0$与$X_N$</li>
<li>从右往左（距离从大到小）尝试放置$X_i$
<ol>
<li>首先放置在右侧，检查距离集合是否满足要求，满足则标记相关的距离为<code>-1</code></li>
<li>如果第一步无解，考虑将$X_I$放置在对称位置，继续检查</li>
</ol>
</li>
<li>如果$X_i$的两个位置均无解，退回（操作还原：距离恢复，即当前栈的<code>max_dist</code>）</li>
</ol>
<p><strong>伪代码实现</strong></p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">bool</span><span style="color:#B392F0"> Reconstruct</span><span style="color:#E1E4E8"> ( DistType </span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[ ], DistSet </span><span style="color:#FFAB70">D</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> N</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> left</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> right</span><span style="color:#E1E4E8"> )</span></span>
<span class="line"><span style="color:#E1E4E8">{</span><span style="color:#6A737D"> /* X[1]...X[left-1] and X[right+1]...X[N] are solved */</span></span>
<span class="line"><span style="color:#F97583">    bool</span><span style="color:#E1E4E8"> Found </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> false</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> ( </span><span style="color:#B392F0">Is_Empty</span><span style="color:#E1E4E8">( D ) )</span></span>
<span class="line"><span style="color:#F97583">        return</span><span style="color:#79B8FF"> true</span><span style="color:#E1E4E8">;</span><span style="color:#6A737D"> /* solved */</span></span>
<span class="line"><span style="color:#E1E4E8">    D_max </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Find_Max</span><span style="color:#E1E4E8">( D );</span></span>
<span class="line"><span style="color:#6A737D">    /* option 1：X[right] = D_max */</span></span>
<span class="line"><span style="color:#6A737D">    /* check if |D_max-X[i]|D is true for all X[i]’s that have been solved */</span></span>
<span class="line"><span style="color:#E1E4E8">    OK </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Check</span><span style="color:#E1E4E8">( D_max, N, left, right );</span><span style="color:#6A737D"> /* pruning */</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> ( OK ) {</span><span style="color:#6A737D"> /* add X[right] and update D */</span></span>
<span class="line"><span style="color:#FFAB70">        X</span><span style="color:#E1E4E8">[right] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> D_max;</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8"> ( i</span><span style="color:#F97583">=</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8">left; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> )  </span><span style="color:#B392F0">Delete</span><span style="color:#E1E4E8">( </span><span style="color:#F97583">|</span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[right]</span><span style="color:#F97583">-</span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[i]</span><span style="color:#F97583">|</span><span style="color:#E1E4E8">, D);</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8"> ( i</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">right</span><span style="color:#F97583">+</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8">N; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> )  </span><span style="color:#B392F0">Delete</span><span style="color:#E1E4E8">( </span><span style="color:#F97583">|</span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[right]</span><span style="color:#F97583">-</span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[i]</span><span style="color:#F97583">|</span><span style="color:#E1E4E8">, D);</span></span>
<span class="line"><span style="color:#E1E4E8">        Found </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Reconstruct</span><span style="color:#E1E4E8"> ( X, D, N, left, right</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8"> );</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> ( </span><span style="color:#F97583">!</span><span style="color:#E1E4E8">Found ) {</span><span style="color:#6A737D"> /* if does not work, undo */</span></span>
<span class="line"><span style="color:#F97583">            for</span><span style="color:#E1E4E8"> ( i</span><span style="color:#F97583">=</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8">left; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> )  </span><span style="color:#B392F0">Insert</span><span style="color:#E1E4E8">( </span><span style="color:#F97583">|</span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[right]</span><span style="color:#F97583">-</span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[i]</span><span style="color:#F97583">|</span><span style="color:#E1E4E8">, D);</span></span>
<span class="line"><span style="color:#F97583">            for</span><span style="color:#E1E4E8"> ( i</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">right</span><span style="color:#F97583">+</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8">N; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> )  </span><span style="color:#B392F0">Insert</span><span style="color:#E1E4E8">( </span><span style="color:#F97583">|</span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[right]</span><span style="color:#F97583">-</span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[i]</span><span style="color:#F97583">|</span><span style="color:#E1E4E8">, D);</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#6A737D">    /* finish checking option 1 */</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> ( </span><span style="color:#F97583">!</span><span style="color:#E1E4E8">Found ) {</span><span style="color:#6A737D"> /* if option 1 does not work */</span></span>
<span class="line"><span style="color:#6A737D">        /* option 2: X[left] = X[N]-D_max */</span></span>
<span class="line"><span style="color:#E1E4E8">        OK </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Check</span><span style="color:#E1E4E8">( </span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[N]</span><span style="color:#F97583">-</span><span style="color:#E1E4E8">D_max, N, left, right );</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> ( OK ) {</span></span>
<span class="line"><span style="color:#FFAB70">            X</span><span style="color:#E1E4E8">[left] </span><span style="color:#F97583">=</span><span style="color:#FFAB70"> X</span><span style="color:#E1E4E8">[N] – D_max;</span></span>
<span class="line"><span style="color:#F97583">            for</span><span style="color:#E1E4E8"> ( i</span><span style="color:#F97583">=</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8">left; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> )  </span><span style="color:#B392F0">Delete</span><span style="color:#E1E4E8">( </span><span style="color:#F97583">|</span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[left]</span><span style="color:#F97583">-</span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[i]</span><span style="color:#F97583">|</span><span style="color:#E1E4E8">, D);</span></span>
<span class="line"><span style="color:#F97583">            for</span><span style="color:#E1E4E8"> ( i</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">right</span><span style="color:#F97583">+</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8">N; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> )  </span><span style="color:#B392F0">Delete</span><span style="color:#E1E4E8">( </span><span style="color:#F97583">|</span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[left]</span><span style="color:#F97583">-</span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[i]</span><span style="color:#F97583">|</span><span style="color:#E1E4E8">, D);</span></span>
<span class="line"><span style="color:#E1E4E8">            Found </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Reconstruct</span><span style="color:#E1E4E8"> (X, D, N, left</span><span style="color:#F97583">+</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, right );</span></span>
<span class="line"><span style="color:#F97583">            if</span><span style="color:#E1E4E8"> ( </span><span style="color:#F97583">!</span><span style="color:#E1E4E8">Found ) {</span></span>
<span class="line"><span style="color:#F97583">                for</span><span style="color:#E1E4E8"> ( i</span><span style="color:#F97583">=</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8">left; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> ) </span><span style="color:#B392F0">Insert</span><span style="color:#E1E4E8">( </span><span style="color:#F97583">|</span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[left]</span><span style="color:#F97583">-</span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[i]</span><span style="color:#F97583">|</span><span style="color:#E1E4E8">, D);</span></span>
<span class="line"><span style="color:#F97583">                for</span><span style="color:#E1E4E8"> ( i</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">right</span><span style="color:#F97583">+</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8">N; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> ) </span><span style="color:#B392F0">Insert</span><span style="color:#E1E4E8">( </span><span style="color:#F97583">|</span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[left]</span><span style="color:#F97583">-</span><span style="color:#FFAB70">X</span><span style="color:#E1E4E8">[i]</span><span style="color:#F97583">|</span><span style="color:#E1E4E8">, D);</span></span>
<span class="line"><span style="color:#E1E4E8">            }</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#6A737D">        /* finish checking option 2 */</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span><span style="color:#6A737D"> /* finish checking all the options */</span></span>
<span class="line"><span style="color:#E1E4E8">    </span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> Found;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre>
<br>
<h4 id="min_max-strategy">Min_max strategy</h4>
<p>定义效用函数： “goodness”
f(P) = W1-W2</p>
<blockquote>
<p>其中W为展开到叶子后，对应的个数</p>
</blockquote>
<h5 id="alpha-beta-剪枝">Alpha-Beta 剪枝</h5>
<ul>
<li>
<p>目的： 用于优化极大极小化算法</p>
</li>
<li>
<p>思路：</p>
<ul>
<li>α prunning： 需要极大化当前层的数据；</li>
<li>β prunning： 需要极小化当前层的数据；</li>
<li><img  src="/_astro/ads-7.DFZFgYDj_Z1L0vVl.webp" alt="alt text" width="1945" height="785" loading="lazy" decoding="async"></li>
</ul>
</li>
<li>
<p>结论： when both techniques are combined.In practice, it limits the searching to only O($\sqrt{N}$)nodes, where N is the size of the full game tree.</p>
</li>
</ul>
<hr>
<h2 id="divide--conquer-分治法">Divide &#x26; Conquer 分治法</h2>
<blockquote>
<p>将一个问题分解为若干个规模较小的相同问题，然后递归地解决这些子问题，最后将这些子问题的解合并得到原问题的解.</p>
</blockquote>
<center>  T(N) = $aT(\frac{N}{b}) +  f(N))$ </center>
<h3 id="closet-points-problem">Closet Points Problem</h3>
<p>二维最近点问题: 给定平面上的 n 个点，找出其中距离最近的两个点.</p>
<ul>
<li>朴素的解决思路： 通过O($N^2$)的时间复杂度枚举所有的可能，找出距离最近的两个点.</li>
<li>分治法：
<ul>
<li>每次将平面分为两个区域，分别寻找子区间内最近的距离，记二者当中的较小值为<code>min</code>;</li>
<li>接下来需要在距离中线<code>min</code>范围内查询是否存在距离小于<code>min</code>的点；</li>
</ul>
</li>
</ul>
<h3 id="复杂度分析">复杂度分析</h3>
<h4 id="代换法">代换法</h4>
<blockquote>
<p>大胆猜测，小心验证.</p>
</blockquote>
<h4 id="递归树法">递归树法</h4>
<ol>
<li><code>a</code>影响了叶子的个数；<code>b</code>影响展开的层数；</li>
<li>e.g. <img  src="/_astro/ads-8.Cfl4rpjb_20rnhA.webp" alt="alt text" width="2096" height="1281" loading="lazy" decoding="async"></li>
</ol>
<h4 id="主方法">主方法</h4>
<blockquote>
<p>参见笔记</p>
</blockquote>
<blockquote>
<p>迭代法求解含根号的复杂度方程.</p>
</blockquote>
<hr>
<h2 id="dynamic-programming">Dynamic Programming</h2>
<blockquote>
<p>Solve sub-problems just once and save answers in a table</p>
</blockquote>
<h3 id="典型模型">典型模型</h3>
<h4 id="fibonacci-numbers">Fibonacci Numbers</h4>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">int</span><span style="color:#B392F0">  Fibonacci</span><span style="color:#E1E4E8"> ( </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> N</span><span style="color:#E1E4E8"> ) </span></span>
<span class="line"><span style="color:#E1E4E8">{   </span><span style="color:#F97583">int</span><span style="color:#E1E4E8">  i, Last, NextToLast, Answer; </span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> ( N </span><span style="color:#F97583">&#x3C;=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8"> )  </span><span style="color:#F97583">return</span><span style="color:#79B8FF">  1</span><span style="color:#E1E4E8">; </span></span>
<span class="line"><span style="color:#E1E4E8">    Last </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> NextToLast </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span><span style="color:#6A737D">    /* F(0) = F(1) = 1 */</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> ( i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> N; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> ) { </span></span>
<span class="line"><span style="color:#E1E4E8">        Answer </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Last </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> NextToLast;</span><span style="color:#6A737D">   /* F(i) = F(i-1) + F(i-2) */</span></span>
<span class="line"><span style="color:#E1E4E8">        NextToLast </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Last; Last </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Answer;</span><span style="color:#6A737D">  /* update F(i-1) and F(i-2) */</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span><span style="color:#6A737D">  /* end-for */</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8">  Answer; </span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre>
<blockquote>
<p>T(N) = O(N)</p>
</blockquote>
<h4 id="ordering-matrix-multiplications">Ordering Matrix Multiplications</h4>
<ul>
<li>矩阵的计算需要满足 左列 = 右行；</li>
<li>满足约束可能会有不同的计算顺序，我们的目标是寻找一个合适的矩阵乘法顺序，使其计算的步骤最少；</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6A737D">/* r contains number of columns for each of the N matrices */</span><span style="color:#E1E4E8"> </span></span>
<span class="line"><span style="color:#6A737D">/* r[ 0 ] is the number of rows in matrix 1 */</span><span style="color:#E1E4E8"> </span></span>
<span class="line"><span style="color:#6A737D">/* Minimum number of multiplications is left in M[ 1 ][ N ] */</span><span style="color:#E1E4E8"> </span></span>
<span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> OptMatrix</span><span style="color:#E1E4E8">( </span><span style="color:#F97583">const</span><span style="color:#F97583"> long</span><span style="color:#FFAB70"> r</span><span style="color:#E1E4E8">[ ], </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> N</span><span style="color:#E1E4E8">, TwoDimArray </span><span style="color:#FFAB70">M</span><span style="color:#E1E4E8"> ) </span></span>
<span class="line"><span style="color:#E1E4E8">{   </span><span style="color:#F97583">int</span><span style="color:#E1E4E8">  i, j, k, L; </span></span>
<span class="line"><span style="color:#F97583">    long</span><span style="color:#E1E4E8">  ThisM; </span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8">( i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> N; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> )   </span><span style="color:#FFAB70">M</span><span style="color:#E1E4E8">[ i ][ i ] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; </span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8">( k </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">; k </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> N; k</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> )</span><span style="color:#6A737D"> /* k = j - i */</span><span style="color:#E1E4E8"> </span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8">( i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> N </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> k; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> ) {</span><span style="color:#6A737D"> /* For each position */</span><span style="color:#E1E4E8"> </span></span>
<span class="line"><span style="color:#E1E4E8">	j </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">+</span><span style="color:#E1E4E8"> k;    </span><span style="color:#FFAB70">M</span><span style="color:#E1E4E8">[ i ][ j ] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Infinity; </span></span>
<span class="line"><span style="color:#F97583">	for</span><span style="color:#E1E4E8">( L </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> i; L </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> j; L</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> ) { </span></span>
<span class="line"><span style="color:#E1E4E8">	    ThisM </span><span style="color:#F97583">=</span><span style="color:#FFAB70"> M</span><span style="color:#E1E4E8">[ i ][ L ] </span><span style="color:#F97583">+</span><span style="color:#FFAB70"> M</span><span style="color:#E1E4E8">[ L </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8"> ][ j ] </span></span>
<span class="line"><span style="color:#F97583">		    +</span><span style="color:#FFAB70"> r</span><span style="color:#E1E4E8">[ i </span><span style="color:#F97583">-</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8"> ] </span><span style="color:#F97583">*</span><span style="color:#FFAB70"> r</span><span style="color:#E1E4E8">[ L ] </span><span style="color:#F97583">*</span><span style="color:#FFAB70"> r</span><span style="color:#E1E4E8">[ j ]; </span></span>
<span class="line"><span style="color:#F97583">	    if</span><span style="color:#E1E4E8"> ( ThisM </span><span style="color:#F97583">&#x3C;</span><span style="color:#FFAB70"> M</span><span style="color:#E1E4E8">[ i ][ j ] )</span><span style="color:#6A737D">  /* Update min */</span><span style="color:#E1E4E8"> </span></span>
<span class="line"><span style="color:#FFAB70">		M</span><span style="color:#E1E4E8">[ i ][ j ] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ThisM; </span></span>
<span class="line"><span style="color:#E1E4E8">	}</span><span style="color:#6A737D">  /* end for-L */</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span><span style="color:#6A737D">  /* end for-Left */</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre>
<blockquote>
<p>T(N) = O($N^3$)</p>
</blockquote>
<h4 id="optimal-binary-search-tree">Optimal Binary Search Tree</h4>
<ul>
<li>目标： 给出<code>N</code>个<code>word</code>，各自的搜索概率是$p_i$. 寻找一个最合适的二叉树结构，使得整体的搜索时间最少，即：</li>
</ul>
<center> T(N) = $\sum_{i=1}^N p_i \cdot (1+d_i)$极小化，其中$d_i$为树中第`i`个节点的深度. </center>
<ul>
<li>
<p><strong>构建</strong>：</p>
<ol>
<li>初始化将各个分区的长度设置为1，<code>pro</code>就是该<code>term</code>的本身；</li>
<li>计算<code>A...B</code>的最优解，指的是我们需要从中选取一个节点<code>C</code>作为根节点；
<ol>
<li>此时，<code>c</code>将原本的序列分为了左右两部分；</li>
<li>由于<code>DP</code>的性质，我们已经在之前计算过子序列的最优解；</li>
<li>因此，只需要遍历<code>c</code>的选择，使得这两个子序列的和最小，得到此时的最优结构；</li>
</ol>
</li>
<li>计算：
<ol>
<li>由于除了<code>root</code>的<code>c</code>，其余节点的<code>depth</code>均为<code>++</code>；</li>
<li>因此，最终的权值，就是所有节点的<code>weight</code>求和 + <code>2.4</code>得到的、两个子序列的和.</li>
</ol>
</li>
</ol>
</li>
<li>
<p><strong>construct</strong></p>
<blockquote>
<p>如果根据<code>构建</code>的结果反向得出此时的结构呢？</p>
</blockquote>
</li>
</ul>
<ol>
<li>从最终的一个序列开始，提取<code>root</code>，得到了左右两个子序列；</li>
<li>整体的结构中，<code>root</code>就是<code>opt</code>的根，且子序列的<code>root</code>就是其孩子，且可以从先前的结构中得到；</li>
<li>重复步骤<code>1</code>，反复提取子序列的<code>root</code>，并不断划分；</li>
</ol>
<h4 id="all-pairs-shortest-path">All-pairs Shortest Path</h4>
<ul>
<li>给定一个图<code>G=(V,E)</code>, 其中<code>V</code>为节点集合，<code>E</code>为边集合，边的权值为<code>w(u,v)</code>；</li>
<li>目标： 计算<code>G</code>中任意两点间的最短路径；</li>
</ul>
<p><strong>朴素的解决</strong>：用每次耗时O($N^2$)的单源最短路径算法，遍历N个节点，可以得到所有节点对之间的最短路径。</p>
<p><strong>DP思路</strong>：</p>
<ol>
<li>二维数组<code>D</code>记录两个点之间的最短路径长度，即结果数组；</li>
<li>初始化时，先将<code>D</code>用边的数组的值填充（自身设置为<code>0</code>），其他值设置为无穷大；</li>
<li>遍历<code>N</code>个节点：每次遍历所有点对，计算经过最外层这个固定点的距离之和是否小于<code>D</code>中记录的最短路径长度；
<ol>
<li><code>yes</code>: 更新<code>D</code>;</li>
<li><code>no</code>: 保留不变；</li>
</ol>
</li>
</ol>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6A737D">/* A[] contains the adjacency matrix with A[ i 1[ i ] = 0 */</span></span>
<span class="line"><span style="color:#6A737D">/* D[] contains the values of the shortest path */</span></span>
<span class="line"><span style="color:#6A737D">/* N is the number of vertices */</span></span>
<span class="line"><span style="color:#6A737D">/* A negative cycle exists iff D[ i ][ i ] &#x3C; 0 */</span></span>
<span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> AllPairs</span><span style="color:#E1E4E8">( TwoDimArray </span><span style="color:#FFAB70">A</span><span style="color:#E1E4E8">, TwoDimArray </span><span style="color:#FFAB70">D</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> N</span><span style="color:#E1E4E8"> ){</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> i, j, k;</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> N; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">)</span><span style="color:#6A737D"> /* Initialize D */</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8">(j </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; j</span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> N; j</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> )</span></span>
<span class="line"><span style="color:#FFAB70">            D</span><span style="color:#E1E4E8">[i][j]</span><span style="color:#F97583">=</span><span style="color:#FFAB70">A</span><span style="color:#E1E4E8">[i][j];</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8">( k </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; k </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> N; k</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> )</span><span style="color:#6A737D"> /* add one vertex k into the path */</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8">( i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> N; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> )</span></span>
<span class="line"><span style="color:#F97583">            for</span><span style="color:#E1E4E8">(j </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; j</span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> N; j</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> )</span></span>
<span class="line"><span style="color:#F97583">                if</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">D</span><span style="color:#E1E4E8">[i][k]</span><span style="color:#F97583">+</span><span style="color:#FFAB70">D</span><span style="color:#E1E4E8">[k][j]</span><span style="color:#F97583">&#x3C;</span><span style="color:#FFAB70">D</span><span style="color:#E1E4E8">[i][j])</span></span>
<span class="line"><span style="color:#6A737D">                /* Update shortest path */</span></span>
<span class="line"><span style="color:#FFAB70">                D</span><span style="color:#E1E4E8">[i][j]</span><span style="color:#F97583">=</span><span style="color:#FFAB70">D</span><span style="color:#E1E4E8">[i][k]</span><span style="color:#F97583">+</span><span style="color:#FFAB70">D</span><span style="color:#E1E4E8">[k][j];</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"></span>
<span class="line"></span></code></pre>
<h4 id="product-assembly">Product Assembly</h4>
<p>问题的情景：</p>
<ul>
<li>有两条生产线来组装一辆汽车；</li>
<li>一共需要经历<code>N</code>个<code>stage</code>组装完成，每次组装消耗一定时间，且每次<code>stage</code>可以选择移动到任意一条生产线；</li>
<li>不同<code>stage</code>以及生产线<code>line</code>之间的组装耗时不同；</li>
<li>题目要求，给定<code>stage</code>以及<code>line</code>的耗时信息，求解最短的组装时间以及执行的<code>line</code>序列；
<img  src="/_astro/ads-9.LWQg3wos_2nbKJx.webp" alt="alt text" width="2016" height="743" loading="lazy" decoding="async"></li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#FFAB70">f</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">][</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]</span><span style="color:#F97583">=</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">; </span><span style="color:#FFAB70">L</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">][</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]</span><span style="color:#F97583">=</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#FFAB70">f</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">][</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]</span><span style="color:#F97583">=</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">; </span><span style="color:#FFAB70">L</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">][</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]</span><span style="color:#F97583">=</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8">(stage</span><span style="color:#F97583">=</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; stage</span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8">n; stage</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">){</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8">(line</span><span style="color:#F97583">=</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">; line</span><span style="color:#F97583">&#x3C;=</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; line</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">){</span></span>
<span class="line"><span style="color:#E1E4E8">    f_stay </span><span style="color:#F97583">=</span><span style="color:#FFAB70"> f</span><span style="color:#E1E4E8">[  line][stage</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">+</span><span style="color:#FFAB70"> t_process</span><span style="color:#E1E4E8">[  line][stage</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#E1E4E8">    f_move </span><span style="color:#F97583">=</span><span style="color:#FFAB70"> f</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">1</span><span style="color:#F97583">-</span><span style="color:#E1E4E8">line][stage</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">+</span><span style="color:#FFAB70"> t_transit</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">1</span><span style="color:#F97583">-</span><span style="color:#E1E4E8">line][stage</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">];</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> (f_stay </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> f_move){</span></span>
<span class="line"><span style="color:#FFAB70">      f</span><span style="color:#E1E4E8">[line][stage] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> f_stay;</span></span>
<span class="line"><span style="color:#FFAB70">      L</span><span style="color:#E1E4E8">[line][stage] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> line;</span><span style="color:#6A737D"> //stay on the same line</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    else</span><span style="color:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#FFAB70">      f</span><span style="color:#E1E4E8">[line][stage] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> f_move;</span></span>
<span class="line"><span style="color:#FFAB70">      L</span><span style="color:#E1E4E8">[line][stage] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#F97583">-</span><span style="color:#E1E4E8">line;</span><span style="color:#6A737D"> //move to the other line</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">//reconstruct the solution</span></span>
<span class="line"><span style="color:#E1E4E8">line </span><span style="color:#F97583">=</span><span style="color:#FFAB70"> f</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">][n]</span><span style="color:#F97583">&#x3C;</span><span style="color:#FFAB70">f</span><span style="color:#E1E4E8">[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">][n]</span><span style="color:#F97583">?</span><span style="color:#79B8FF">0</span><span style="color:#F97583">:</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8">(stage</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">n; stage</span><span style="color:#F97583">></span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">; stage</span><span style="color:#F97583">--</span><span style="color:#E1E4E8">){</span></span>
<span class="line"><span style="color:#FFAB70">  plan</span><span style="color:#E1E4E8">[stage] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> line;</span></span>
<span class="line"><span style="color:#E1E4E8">  line </span><span style="color:#F97583">=</span><span style="color:#FFAB70"> L</span><span style="color:#E1E4E8">[line][stage];</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span>
<span class="line"></span></code></pre>
<h3 id="dp的设计思路">DP的设计思路</h3>
<ol>
<li>得到最优解的计算方法（递推公式）；</li>
<li>以固定的顺序，递归计算最优解并填入<code>table</code>；</li>
<li><code>reconstruct</code>解决策略得到输出.</li>
</ol>
<hr>
<h2 id="greedy-algorithms">Greedy Algorithms</h2>
<p><strong>贪心算法</strong>： 每个决策阶段都选择当前看起来最优的解决方案，从而希望能够达到全局最优解</p>
<blockquote>
<p>核心思想是局部最优选择，通过一系列局部最优的选择，来达到全局最优的目标。</p>
</blockquote>
<h3 id="activity-selection-problem">Activity Selection Problem</h3>
<ul>
<li>
<p>问题抽象：</p>
<ul>
<li>给定若干个区间，包含开始与结束的时间点；</li>
<li>给定一个总时间段，求解最多能够在这个时间段上放置多少个区间</li>
</ul>
</li>
<li>
<p>最优贪心策略：</p>
<ul>
<li>每次选择结束时间最早的区间</li>
</ul>
</li>
</ul>
<h3 id="huffman-coding">Huffman Coding</h3>
<p>每个节点具有属性<code>weight</code>，我们希望构造一棵二叉树，使得树的权值最小。</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> Huffman</span><span style="color:#E1E4E8"> ( PriorityQueue  </span><span style="color:#FFAB70">heap</span><span style="color:#E1E4E8">[ ],  </span><span style="color:#F97583">int</span><span style="color:#FFAB70">  C</span><span style="color:#E1E4E8"> )</span></span>
<span class="line"><span style="color:#E1E4E8">{   consider the C characters as C single node binary trees,</span></span>
<span class="line"><span style="color:#E1E4E8">     and initialize them into a min heap;</span></span>
<span class="line"><span style="color:#F97583">     for</span><span style="color:#E1E4E8"> ( i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> C; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> ) { </span></span>
<span class="line"><span style="color:#E1E4E8">        create a new node;</span></span>
<span class="line"><span style="color:#6A737D">        /* be greedy here */</span></span>
<span class="line"><span style="color:#E1E4E8">        delete root from min heap and attach it to left_child of node;</span></span>
<span class="line"><span style="color:#E1E4E8">        delete root from min heap and attach it to right_child of node;</span></span>
<span class="line"><span style="color:#E1E4E8">        weight of node </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> sum of weights of its children;</span></span>
<span class="line"><span style="color:#6A737D">        /* weight of a tree = sum of the frequencies of its leaves */</span></span>
<span class="line"><span style="color:#E1E4E8">        insert node into min heap;</span></span>
<span class="line"><span style="color:#E1E4E8">   }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre>
<blockquote>
<ol>
<li>每次构建一个<code>new node</code>时，从堆中提取两个最小的节点，分别放在左右子树，可见满足BST性质；</li>
<li>计算<code>cost</code>时，将编码字长 x 频率然后累加得到；</li>
<li>时间复杂度：O($C\log C$)</li>
</ol>
</blockquote>
<p>e.g.<img  src="/_astro/ads-10.C6-lYno3_ZOBAhJ.webp" alt="alt text" width="1484" height="986" loading="lazy" decoding="async"></p>
<h2 id="np-complete-problems">NP Complete Problems</h2>
<h3 id="basic-concepts">Basic Concepts</h3>
<p><strong>NP问题</strong> — Nondeterministic polynomial-time</p>
<ol>
<li>非确定性图灵机可以用多项式时间的算法解决 的问题称为~；</li>
<li>意味着用确定性图灵机可以用多项式时间的算法来<strong>验证</strong>;</li>
</ol>
<blockquote>
<p>非确定性图灵机指的是：图灵机有无限的并行”纸带“，使得如果对于存在正确路径的k条路径，可以立即得到正确的答案；而确定性图灵机只能通过遍历寻找正确路径；
对于不可判断类型的问题，非确定性图灵机也无法得出答案；</p>
</blockquote>
<p><strong>Decidable Problems</strong> : 可判定问题</p>
<blockquote>
<p>指的是那些可以通过算法在有限时间内解决的问题;
停机问题 <strong>Halting Problem</strong> 属于典型的不可计算问题；</p>
</blockquote>
<p><strong>NPC问题</strong></p>
<ol>
<li>本身是 <strong>NP</strong>问题（解可以在多项式时间内验证）；</li>
<li>NP类中的其他问题<strong>都</strong>可以在<strong>多项式时间内规约</strong>到它；
<ol>
<li>将一个问题用多项式时间转换为另一个问题</li>
</ol>
</li>
</ol>
<blockquote>
<p>如果我们找到了解决某个NP完全问题的多项式时间算法，那么所有NP问题都可以用同样的方法在多项式时间内解决，这将意味着 <em><strong>P = NP</strong></em>；</p>
</blockquote>
<p>并非所有的可判定问题都属于<code>NP</code>类</p>
<blockquote>
<p>e.g. <strong>验证一个图不存在哈密顿回路</strong> 进行验证时必须枚举所有可能的路径，这无法用多项式时间的算法解决；</p>
</blockquote>
<h3 id="经典模型">经典模型</h3>
<h4 id="circuit-sat">Circuit-SAT</h4>
<ul>
<li>地位： 是第一个被证明为 <em><strong>NPC</strong></em> 的问题</li>
<li>内容： 给出一个布尔表达式，判断是否存在一种布尔赋值，使得表达式的输出为<code>1</code>；</li>
</ul>
<blockquote>
<p>“Input a boolean expression and ask if it has an assignment to the variables that gives the expression a value of 1.”</p>
</blockquote>
<ul>
<li>3-SAT ：是该问题的一个特例，要求三个变量为一组的形式</li>
</ul>
<h4 id="哈密顿回路-npc">哈密顿回路 NPC</h4>
<p>给定一个图，判断是否存在一条路径，使得它经过图中的<strong>每个点</strong>恰好一次，且最后<strong>回到起点</strong>。</p>
<h4 id="旅行商问题-npc">旅行商问题 NPC</h4>
<p>判定版本：给定一个完全图，判断是否存在一条路径，使得它经过图中的每个点恰好一次，且最后回到起点，且路径长度不超过<code>k</code></p>
<h4 id="vertex-cover-problem-npc">vertex cover problem （NPC）</h4>
<p><strong>相关概念</strong></p>
<ul>
<li>完全子图 Clique(团) ：指图中的一个顶点子集，这些顶点两两之间都有边连接；</li>
<li>团问题： 给定一个无向图和整数K，判断图中是否存在一个包含至少K个顶点的完全子图；</li>
<li>
<blockquote>
<p>属于 <strong>NPC</strong> 问题；</p>
</blockquote>
</li>
</ul>
<p><strong>Vertex Cover Problem</strong></p>
<ul>
<li>给定一个无向图和整数K，判断能够找到一个顶点集合V’，使之满足这样的条件：
<ul>
<li>V’内顶点个数不超过<code>k</code>；</li>
<li>无向图中所有的边都被V’的顶点覆盖，即不存在两个顶点都不在V’当中的边;</li>
</ul>
</li>
</ul>
<p><strong>证明</strong>：</p>
<ul>
<li>属于 NP 类：能够在O($N^3$)的时间内验证给出的解是否正确；</li>
<li>可以由已知的NPC问题（团问题）经过多项式时间规约得到；</li>
</ul>
<p>证明问题<code>A</code>是一个 <em><strong>NP</strong></em>需要经历两步：</p>
<ul>
<li><code>A</code>的解可以在多项式时间内被验证；</li>
<li>NPC问题的<code>B</code>可以在多项式时间规约下转化为<code>A</code>；</li>
</ul>
<h2 id="approximation">Approximation</h2>
<h3 id="basic-concepts-1">Basic Concepts</h3>
<ul>
<li>近似比： 精确解与近似算法结果的比值（与其倒数取<code>max</code>的结果），$\rho = 1+\epsilon$；</li>
<li><strong>PTAS</strong>：对于给定的 $\epsilon$，算法的时间复杂度是<code>n</code>的多项式；</li>
<li><strong>FPTAS</strong>：对于<code>n</code>与$\frac{1}{\epsilon}$均为多项式时间复杂度；</li>
</ul>
<h3 id="approximate-bin-packing">Approximate Bin Packing</h3>
<p><strong>装箱问题</strong>： 给定<code>N</code>个大小处于0~1之间的<code>item</code>，每个<code>bin</code>的大小为<code>1</code>，要求寻找最少、且能装载所有<code>item</code>的<code>bin</code>的数量；</p>
<p>在线算法下的三种模型：</p>
<h4 id="next-fit">Next Fit</h4>
<p>总是查看当前 <strong>最后一个</strong> <code>bin</code>：</p>
<ul>
<li>
<p>如果可以容纳<code>item</code>，则放入；</p>
</li>
<li>
<p>否则，创建一个新的<code>bin</code>；</p>
</li>
<li>
<p>NF策略使用不超过<code>2M-1</code>个<code>bin</code>；</p>
<blockquote>
<p><code>M</code>为最优解的 #bin;</p>
</blockquote>
</li>
</ul>
<h4 id="first-fit">First Fit</h4>
<p>从前往后扫描所有的<code>bin</code>，选择第一个可以装载当前<code>item</code>的<code>bin</code>：</p>
<ul>
<li>FF策略使用不超过 $\lfloor{1.7M} \rfloor$ 个<code>bin</code>；</li>
</ul>
<h4 id="best-fit">Best Fit</h4>
<p>选择能够容纳当前 <code>item</code> 且剩余空间最小的 <code>bin</code>;</p>
<ul>
<li>BF策略同样使用不超过 $\lfloor{1.7M} \rfloor$ 个<code>bin</code>；</li>
</ul>
<hr>
如果限定使用在线算法，其中 **最优** 的近似解法的最坏情况的近似比也为 $\frac{5}{3}$；
<h4 id="first-fit-decreasing">First Fit Decreasing</h4>
<p>将<code>item</code>按照<code>size</code>降序，然后使用<code>FF</code>或者<code>BF</code>策略；</p>
<ul>
<li>FFD策略使用不超过 $\frac{11}{9}M + \frac{6}{9}$ 个<code>bin</code>；</li>
</ul>
<h3 id="knapsack-problem">Knapsack Problem</h3>
<ul>
<li><strong>问题描述</strong>：
<ul>
<li>内容：给定容量为<code>M</code>的背包，以及<code>N</code>个item、各个物件对应的重量和利润，要求在不超过背包容量的前提下，使得背包中利润最大化；</li>
<li>分类：
<ul>
<li>物件可自由拆分 fraction version</li>
<li>每个物件只有 选或者完全不选 的状态 0-1 version</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="fraction-version">Fraction Version</h4>
<p>计算profit density即单位重量的利润，然后据此对每个物件进行排序，每次取用性价比最高的物件，直到无法装入为止；</p>
<h4 id="0-1-version">0-1 version</h4>
<ul>
<li>不同的贪心策略：
<ul>
<li><strong>maximum profit</strong> :每次选取最大利润的物件；</li>
<li><strong>profit density</strong> :每次选取最高性价比的物件；</li>
</ul>
</li>
</ul>
<p>记$P_{greedy} = max{P_{max},P_{pd}}$, 其近似比为 <strong>2</strong>；</p>
<h3 id="k-center-problem">K-center problem</h3>
<ul>
<li>给定N个<code>site</code>以及整数<code>k</code>,要求选取<code>k</code>个中心，使得它们可以覆盖所有的<code>site</code>且覆盖半径尽可能小；</li>
<li>设<code>S'</code>为未被覆盖的点的集合；</li>
</ul>
<p><strong>Navie greedy</strong>: 每次选择<code>S'</code>当中距离最远的两个点，将中心设置在中间；</p>
<p><strong>2-r greedy</strong>: 从(0,$r_{max}$)当中选择<code>x</code>，作为下面步骤的输入参数</p>
<ul>
<li>从<code>S'</code>中 <strong>随机</strong> 选择一个作为中心<code>C</code>的一部分；</li>
<li>删除在第一步中距离这个中心不足<code>2x</code>的<code>site</code>，更新<code>S'</code>；</li>
<li>当<code>S'</code>中不存在顶点，即所有的点都被覆盖，停止操作；</li>
<li>检查此时<code>C</code>中的中心个数<code>N</code>：
<ul>
<li>若<code>N</code> > <code>K</code>，说明选定的半径过小，需要增大<code>x</code>，再次求解；</li>
<li>若<code>N</code> &#x3C; <code>K</code>，说明选定的半径过大，需要减小<code>x</code>，再次求解；</li>
</ul>
</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#E1E4E8">Centers  Greedy</span><span style="color:#F97583">-</span><span style="color:#FDAEB7;font-style:italic">2r</span><span style="color:#E1E4E8"> ( Sites </span><span style="color:#FFAB70">S</span><span style="color:#E1E4E8">[ ], </span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> n, </span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> K, </span><span style="color:#F97583">double</span><span style="color:#E1E4E8"> r )</span></span>
<span class="line"><span style="color:#E1E4E8">{   Sites  S’[ ] </span><span style="color:#F97583">=</span><span style="color:#FFAB70"> S</span><span style="color:#E1E4E8">[ ];</span><span style="color:#6A737D"> /* S’ is the set of the remaining sites */</span></span>
<span class="line"><span style="color:#E1E4E8">    Centers  </span><span style="color:#FFAB70">C</span><span style="color:#E1E4E8">[ ] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ∅;</span></span>
<span class="line"><span style="color:#F97583">    while</span><span style="color:#E1E4E8"> ( S’[ ] </span><span style="color:#F97583">!=</span><span style="color:#E1E4E8"> ∅ ) {</span></span>
<span class="line"><span style="color:#E1E4E8">        Select any s from S’ and add it to C;</span></span>
<span class="line"><span style="color:#E1E4E8">        Delete all s’ from S’ that are at </span><span style="color:#B392F0">dist</span><span style="color:#E1E4E8">(s’, s) </span><span style="color:#F97583">&#x3C;=</span><span style="color:#FDAEB7;font-style:italic"> 2r</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span><span style="color:#6A737D"> /* end-while */</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> ( </span><span style="color:#F97583">|</span><span style="color:#E1E4E8">C</span><span style="color:#F97583">|</span><span style="color:#F97583"> &#x3C;=</span><span style="color:#E1E4E8"> K ) </span><span style="color:#F97583">return</span><span style="color:#E1E4E8"> C;</span></span>
<span class="line"><span style="color:#F97583">    else</span><span style="color:#B392F0"> ERROR</span><span style="color:#E1E4E8">(No set of K centers with covering radius at most r);</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre>
<p><strong>Smarter way</strong>: 在<code>2-r</code>策略的基础上得到，每次不是随机选择<code>S'</code>当中的点，而是选择在<code>C</code>的覆盖范围外最远的那个顶点；</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#E1E4E8">Centers  Greedy</span><span style="color:#F97583">-</span><span style="color:#B392F0">Kcenter</span><span style="color:#E1E4E8"> ( Sites </span><span style="color:#FFAB70">S</span><span style="color:#E1E4E8">[ ], </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> n</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> K</span><span style="color:#E1E4E8"> )</span></span>
<span class="line"><span style="color:#E1E4E8">{   Centers  </span><span style="color:#FFAB70">C</span><span style="color:#E1E4E8">[ ] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ∅;</span></span>
<span class="line"><span style="color:#E1E4E8">    Select any s from S and add it to C;</span></span>
<span class="line"><span style="color:#F97583">    while</span><span style="color:#E1E4E8"> ( </span><span style="color:#F97583">|</span><span style="color:#E1E4E8">C</span><span style="color:#F97583">|</span><span style="color:#F97583"> &#x3C;</span><span style="color:#E1E4E8"> K ) {</span></span>
<span class="line"><span style="color:#E1E4E8">        Select s from S with maximum </span><span style="color:#B392F0">dist</span><span style="color:#E1E4E8">(s, C);</span></span>
<span class="line"><span style="color:#E1E4E8">        Add s it to C;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span><span style="color:#6A737D"> /* end-while */</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> C;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre>
<ul>
<li><code>2-r</code>与改进版本的近似比都是 <em><strong>2</strong></em>；</li>
<li>除非 <strong>P=NP</strong>，否则不存在近似比小于 <strong>2</strong> 的近似算法；</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<ol>
<li><strong>Optimality</strong>: 解的质量</li>
<li><strong>Efficiency</strong>: 解的效率</li>
<li><strong>All instances</strong>: 是否覆盖所有情况</li>
</ol>
<p>1+2: 对于特殊情况的 <strong>准确而高效</strong> 的算法；<br>
1+3：对于所有情况的准确算法；<br>
2+3：对于所有情况的高效算法；（牺牲了精确）</p>
<p>即使 <strong>P=NP</strong>，也无法三个愿望一次满足.</p>
<h2 id="local-search">Local Search</h2>
<p>先找到一个可行解，以及量化其优程度的目标函数，再在这个可行解上寻求优化，直到达到局部最优解。</p>
<ul>
<li><em><strong>FS</strong></em>: feasible solution</li>
<li>S’: 由S经过微调得到；</li>
<li>N(S): S的邻域；</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#E1E4E8">SolutionType </span><span style="color:#B392F0">Gradient_descent</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">{   Start from a feasible solution S 属于 FS ;</span></span>
<span class="line"><span style="color:#E1E4E8">    MinCost </span><span style="color:#F97583">=</span><span style="color:#B392F0"> cost</span><span style="color:#E1E4E8">(S);</span></span>
<span class="line"><span style="color:#F97583">    while</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#E1E4E8">        S’ </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Search</span><span style="color:#E1E4E8">( </span><span style="color:#B392F0">N</span><span style="color:#E1E4E8">(S) );</span><span style="color:#6A737D"> /* find the best S’ in N(S) */</span></span>
<span class="line"><span style="color:#E1E4E8">        CurrentCost </span><span style="color:#F97583">=</span><span style="color:#B392F0"> cost</span><span style="color:#E1E4E8">(S’);</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> ( CurrentCost </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> MinCost ) {</span></span>
<span class="line"><span style="color:#E1E4E8">            MinCost </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> CurrentCost;    S </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> S’;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#F97583">        else</span><span style="color:#F97583">  break</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> S;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre>
<h3 id="vertex-cover-problem">Vertex Cover Problem</h3>
<ul>
<li>Version:
<ul>
<li>判定性：我们已经在之前讨论过，即给定一个无向图和整数K，判断是否存在一个点的集合V’，使得V’的元素个数在不超过K的情况下，可以覆盖无向图中所有的边；</li>
<li><strong>非判定性</strong>：找到V’的最小规模，使得可以覆盖所有边；</li>
</ul>
</li>
</ul>
<blockquote>
<p>我们将围绕第二个版本进行讨论.</p>
</blockquote>
<p>选择一个好的起点对于得到靠近最优解的结果十分重要，如果运气不太好，选择的点可能会陷入远离最优的局部最优；</p>
<p>如果依旧以一定的概率选择接受邻域中的最优解（即使相比于当前最优较为差劲），那么我们具有了跳出上述“局部最优”的机会：
<img  src="/_astro/ads_11.DTEgaJ3f_FfR8E.webp" alt="alt text" width="1522" height="981" loading="lazy" decoding="async"></p>
<p><strong>Simulated Annealing</strong> 模拟退火：</p>
<ul>
<li>T越高，跳出局部最优的可能性就越高，这有助于在算法的前期避免陷入局部最优；</li>
<li>因此，我们可以设置一系列逐渐降低的 <strong>T</strong>（模拟退火），使得算法最终趋近全局的最优解；</li>
</ul>
<h3 id="hopfield-neural-networks">Hopfield Neural Networks</h3>
<ul>
<li>G为有权无向图，边的权值记为<code>w</code>；</li>
<li>理想情况下：
<ul>
<li>如果w&#x3C;0,表示相连的2个顶点具有相同的状态；否则具有不同的状态；</li>
<li>其中顶点的状态用$S_u$与$S_v$表示；</li>
<li>但是，对于给定的图，我们可能无法找到满足所有理想状态的顶点状态，需要引出以下概念；</li>
</ul>
</li>
<li>补充概念：记 k = $W_e \cdot S_v \cdot S_u$
<ul>
<li><em><strong>good</strong></em>: 对于 <strong>边</strong> 来说，如果满足 k &#x3C; 0, 那么这条是好边；</li>
<li><em><strong>satisfied</strong></em>: 对于 <strong>点</strong> 来说， 如果它所包含的好边的<strong>权值</strong>要大于坏边的权值，那么为可满足
<blockquote>
<p>即 k 的求和不大于0；</p>
</blockquote>
</li>
<li><em><strong>stable</strong></em>: 对于<strong>configuration</strong>来说，如果所有的顶点均可满足，那么为稳定；</li>
</ul>
</li>
</ul>
<p>据此，我们可以完整地描述问题的理想输出：</p>
<center> find a stable S for network G </center>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#E1E4E8">ConfigType </span><span style="color:#B392F0">State_flipping</span><span style="color:#E1E4E8">()</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#E1E4E8">    Start from an arbitrary configuration S;</span></span>
<span class="line"><span style="color:#F97583">    while</span><span style="color:#E1E4E8"> ( </span><span style="color:#F97583">!</span><span style="color:#B392F0"> IsStable</span><span style="color:#E1E4E8">(S) ) {</span></span>
<span class="line"><span style="color:#E1E4E8">        u </span><span style="color:#F97583">=</span><span style="color:#B392F0"> GetUnsatisfied</span><span style="color:#E1E4E8">(S);</span></span>
<span class="line"><span style="color:#E1E4E8">        su </span><span style="color:#F97583">=</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8"> su;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> S;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre>
<blockquote>
<ol>
<li>从任意的<strong>配置</strong>开始，</li>
<li>通过计算点的<strong>可满足性</strong>来更新：找到一个不满足点，将其状态翻转；</li>
<li>重复步骤2，直到所有的点都满足；</li>
<li>输出稳定的配置S；</li>
</ol>
</blockquote>
<p><em><strong>clain</strong></em>: 上述的<code>state-flipping</code>算法在获得最终输出的过程中，<strong>最多</strong>执行$w_e$次状态翻转；</p>
<ul>
<li><strong>proof</strong>:
<ul>
<li>每次翻转状态，一定伴随着好边 <code>k</code>值的增大以及坏边<code>k</code>值的减小(在全局范围内)，由于状态为正负一，因此等价于好边权值（绝对值）的增大；</li>
<li>好边总权值的上界，就是无向图的权值和；</li>
<li>而每次翻转使得好边权值至少增加 <strong>1</strong>，因此最多需要翻转 $W_e$ 次；</li>
</ul>
</li>
</ul>
<p><em><strong>claim</strong></em>: 采用局部搜索方法，得到的局部最优一定是一个稳定的配置</p>
<blockquote>
<p>因为局部最优意味着无法找到另一个不被满足的点，即邻域中没有更优解；</p>
</blockquote>
<h3 id="maximum-cut-problem">Maximum Cut Problem</h3>
<ul>
<li>
<p>input: 有权无向图<code>G</code>, 边的权值均<code>></code>0;</p>
</li>
<li>
<p>output: 找到顶点分区<code>A</code>,<code>B</code>使得<code>A</code>和<code>B</code>之间的所有边的权值之和最大，记为<code>W(A,B)</code>；</p>
</li>
<li>
<p>application</p>
<ul>
<li><strong>Toy</strong>:
<ul>
<li>假设有一系列会议分别在早上和下午召开，人们可以在一个时间段内任选一个会议参加，且必须参加两场会议；</li>
<li>现在进行如下建模：
<ul>
<li>顶点<code>v</code>表示不同的会议，且分成了2个分区，表示不同的时间段；</li>
<li>边<code>e</code>表示人们的选择：1条边连接的2个顶点表示这个人希望同时参加这2个会议；</li>
</ul>
</li>
<li>由此，我们希望<code>e</code>连接的2个顶点来自不同的分区，这样的边越多越好；</li>
<li>这就转化为了最大割问题，其中每条边的权值为<code>1</code>；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>local search</strong>视角下的分析：</p>
<ul>
<li>问题：最大化<code>W(A,B)</code>；</li>
<li>feasible solution：任意分区；</li>
<li>S~S’：将任意的一个顶点转化其分区的位置；</li>
</ul>
<p>由此，我们不难发现，<code>W(A,B)</code>实际上就是 <strong>好边</strong> 的定义！只不过在此处，边的权值都是正的，<code>W</code>当中的点来自不同的分区，也就是不同的 <em><strong>state</strong></em>！</p>
<blockquote>
<p>问题可以转换为求解 好边的权值的最大化.</p>
</blockquote>
<h4 id="how-good-is-this-local-optimum">How good is this local optimum?</h4>
<p><em><strong>cliam</strong></em>:<br>
通过本地搜索得到的局部最优解，其<code>W</code>值最小为全局最优的 <strong>1/2</strong>.</p>
<blockquote>
<p>proof参见 <strong>prodrafts</strong>.</p>
</blockquote>
<ul>
<li>其他结论：
<ul>
<li>存在 <strong>1.1382</strong>近似比的近似算法 for <code>Max-Cut</code>问题；</li>
<li>除非 $P = NP$，否则不存在$\frac{17}{16}$的近似算法</li>
<li>可能无法在多项式时间内完成.
<ul>
<li>策略：在选择<code>node</code>进行翻转时，考虑采用$Big-improvement-flip$方法.</li>
</ul>
 <center> 超过$\frac{2\epsilon}{|V|}W(A,B)$改进的解将被接受 </center>
</li>
</ul>
</li>
</ul>
<p>在 <strong>Big-improvement-flip</strong> 策略下：</p>
<ul>
<li>解的质量： $(2+ \epsilon) \cdot w(A,B) \geq w(A^*,B^*)$</li>
<li>所需的时间： 最多进行$O(\frac{n}{\epsilon} \cdot \log W)$次flip.</li>
</ul>
<h4 id="better-local">better local</h4>
<p><strong>neighbour</strong>不应该太小，否则容易陷入局部最优；同时不应该太大，否则算法效率低下.</p>
<p>为了调和上述矛盾，采用一种 <strong>k-flip</strong> 的策略：每次用$O(n^k)$的时间搜索邻域；</p>
<blockquote>
<p>在k次的flip之后调用一次评估函数来检验质量，判断是否需要更新；
在一次的搜索过程当中，可以通过<code>mark</code>的方式来避免重复flip一个节点.(mark仅在一次的<code>run</code>中生效).</p>
</blockquote>
<h3 id="conclusion-1">Conclusion</h3>
<p>local search的组成要素：</p>
<ul>
<li>邻域：每次搜索的空间；</li>
<li>评价函数：衡量邻域中解的好坏；</li>
<li>S~S’：搜索策略；</li>
</ul>
<blockquote>
<p>每次搜索到较优的就更新，而不是遍历所有的邻域</p>
</blockquote>
<h2 id="randomized-algorithms">Randomized Algorithms</h2>
<ul>
<li>
<p>随机化：输入可能表现为随机化，算法的处理思想也可能是随机化的. 本章我们讨论的是后者.</p>
</li>
<li>
<p>为什么需要随机化：</p>
<ul>
<li>利用高效的随机化算法，以 <strong>很高的概率</strong> 获得正确答案.</li>
</ul>
</li>
</ul>
<h3 id="the-hiring-problem">The Hiring Problem</h3>
<p><strong>问题描述</strong></p>
<ul>
<li>有$N$个面试者可供聘用；</li>
<li>面试和雇佣分别需要消耗一定的时间$C_i与C_h$,且后者是主要时间消耗；</li>
<li>我们讨论的是面试和雇佣需要的时间总和，而非算法的运行时间；</li>
</ul>
<h4 id="naive-approach">Naive Approach</h4>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">int</span><span style="color:#B392F0"> Hiring</span><span style="color:#E1E4E8"> ( EventType </span><span style="color:#FFAB70">C</span><span style="color:#E1E4E8">[ ], </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> N</span><span style="color:#E1E4E8"> )</span></span>
<span class="line"><span style="color:#E1E4E8">{</span><span style="color:#6A737D">   /* candidate 0 is a least-qualified dummy candidate */</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> Best </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> BestQ </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> the quality of candidate </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> ( i</span><span style="color:#F97583">=</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8">N; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> ) {</span></span>
<span class="line"><span style="color:#E1E4E8">        Qi </span><span style="color:#F97583">=</span><span style="color:#B392F0"> interview</span><span style="color:#E1E4E8">( i );</span><span style="color:#6A737D"> /* Ci */</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> ( Qi </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> BestQ ) {</span></span>
<span class="line"><span style="color:#E1E4E8">            BestQ </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Qi;</span></span>
<span class="line"><span style="color:#E1E4E8">            Best </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> i;</span></span>
<span class="line"><span style="color:#B392F0">            hire</span><span style="color:#E1E4E8">( i );</span><span style="color:#6A737D">  /* Ch */</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> Best;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre>
<blockquote>
<p>Worst case: 面试者以质量递增的次序出现时，将会花费$O(NC_h)$的时间<br>
为了避免上述情况的发生，我们考虑面试者的质量是random的.</p>
</blockquote>
<h4 id="randomized-approach">Randomized Approach</h4>
<p>如果面试者的质量是 <strong>random</strong>:</p>
<ul>
<li>对于前<code>i</code>个面试者，每个人被雇佣的概率是相等的，均为$\frac{1}{i}$;</li>
<li>N个面试者对应的总hire数量：$\sum_{i=1}^N \frac{{1}}{i} = \ln N$</li>
<li>由此，整体的时间消耗为：$O(C_h\cdot\ln N + N\cdot C_i)$</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">int</span><span style="color:#B392F0"> RandomizedHiring</span><span style="color:#E1E4E8"> ( EventType </span><span style="color:#FFAB70">C</span><span style="color:#E1E4E8">[ ], </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> N</span><span style="color:#E1E4E8"> )</span></span>
<span class="line"><span style="color:#E1E4E8">{</span><span style="color:#6A737D">   /* candidate 0 is a least-qualified dummy candidate */</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> Best </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> BestQ </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> the quality of candidate </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">    randomly permute the list of candidates;</span><span style="color:#6A737D"> //我们需要在此处随机化输入</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> ( i</span><span style="color:#F97583">=</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8">N; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> ) {</span></span>
<span class="line"><span style="color:#E1E4E8">        Qi </span><span style="color:#F97583">=</span><span style="color:#B392F0"> interview</span><span style="color:#E1E4E8">( i );</span><span style="color:#6A737D"> /* Ci */</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> ( Qi </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> BestQ ) {</span></span>
<span class="line"><span style="color:#E1E4E8">            BestQ </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Qi;</span></span>
<span class="line"><span style="color:#E1E4E8">            Best </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> i;</span></span>
<span class="line"><span style="color:#B392F0">            hire</span><span style="color:#E1E4E8">( i );</span><span style="color:#6A737D">  /* Ch */</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre>
<p>接下来我们需要考虑如何 <strong>随机化</strong> 排列面试者:</p>
<blockquote>
<p>一种可行的排列方式：</p>
</blockquote>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">void</span><span style="color:#B392F0"> PermuteBySorting</span><span style="color:#E1E4E8"> ( ElemType </span><span style="color:#FFAB70">A</span><span style="color:#E1E4E8">[ ], </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> N</span><span style="color:#E1E4E8"> )</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> ( i</span><span style="color:#F97583">=</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8">N; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> )</span></span>
<span class="line"><span style="color:#FFAB70">        A</span><span style="color:#E1E4E8">[i].P </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#F97583"> +</span><span style="color:#B392F0"> rand</span><span style="color:#E1E4E8">()</span><span style="color:#F97583">%</span><span style="color:#E1E4E8">(N</span><span style="color:#F97583">^</span><span style="color:#79B8FF">3</span><span style="color:#E1E4E8">); </span></span>
<span class="line"><span style="color:#6A737D">        /* makes it more likely that all priorities are unique */</span></span>
<span class="line"><span style="color:#E1E4E8">    Sort A, using P as the sort keys;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre>
<blockquote>
<ol>
<li>A是待排序的面试者；</li>
<li>我们通过取用1~$N^3$之间的值，赋值给A上元素的属性P；</li>
<li>最后利用P来对A进行排序，达到随机的效果.</li>
</ol>
</blockquote>
<p><strong>claim</strong>: 上述的算法能够以很高的概率获得随机的序列.</p>
<hr>
<p>在之前我们讨论的随机化算法中，对于输入的随机化处理要求输入是 <strong>offline</strong> 的，这样才能够调用<code>PermuteBySorting</code>.<br>
在下面的讨论中，我们需要处理<code>online</code>的输入，即输入的顺序是 <strong>不确定的</strong> 的.</p>
<h4 id="online-approach">Online Approach</h4>
<blockquote>
<p>只hire<code>N</code>个人当中的1个.</p>
</blockquote>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">int</span><span style="color:#B392F0"> OnlineHiring</span><span style="color:#E1E4E8"> ( EventType </span><span style="color:#FFAB70">C</span><span style="color:#E1E4E8">[ ], </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> N</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">int</span><span style="color:#FFAB70"> k</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">{</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> Best </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> N;</span><span style="color:#6A737D"> //先假设全局最优是最后一个面试者</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> BestQ </span><span style="color:#F97583">=</span><span style="color:#F97583"> -</span><span style="color:#E1E4E8"> infinity ;</span><span style="color:#6A737D"> //BestQ是前k个最优，初始化为负无穷</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> ( i</span><span style="color:#F97583">=</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8">k; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> ) {</span></span>
<span class="line"><span style="color:#E1E4E8">        Qi </span><span style="color:#F97583">=</span><span style="color:#B392F0"> interview</span><span style="color:#E1E4E8">( i );</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> ( Qi </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> BestQ )   BestQ </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Qi;</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> ( i</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">k</span><span style="color:#F97583">+</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8">N; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8"> ) {</span></span>
<span class="line"><span style="color:#E1E4E8">        Qi </span><span style="color:#F97583">=</span><span style="color:#B392F0"> interview</span><span style="color:#E1E4E8">( i );</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> ( Qi </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> BestQ ) {</span></span>
<span class="line"><span style="color:#E1E4E8">            Best </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> i;</span></span>
<span class="line"><span style="color:#F97583">            break</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> Best;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre>
<p>算法的整体思想：</p>
<ul>
<li>先假设全局最优的Best是最后一个面试者；</li>
<li>在前k个面试者中找到局部最优BeseQ;</li>
<li>在K+1~N-1中比较当前面试者与BestQ，如果找到了更优的面试者，将Best设置为i,立即 <em><strong>break</strong></em>;</li>
<li>返回 Best.</li>
</ul>
<blockquote>
<p>如果在第二次搜索当中没有找到比局部更优的，并不返回局部最优，而是一开始的 <em><strong>N</strong></em>,因为循环中不涉及对Best的更新!</p>
</blockquote>
<br>
<p>对于给定的N，如何选择k使得我们可以正确选择到全局最优？</p>
<p><em><strong>claim</strong></em>: for integer K,
$
k_{best} = \lfloor \frac{N}{e} \rfloor
$
此时对应的概率为$\frac{1}{e}$.</p>
<h3 id="quicksort">QuickSort</h3>
<p><strong>相关概念</strong>：</p>
<ul>
<li>Central splitter： the pivot that divides the set so that each side contains at least n/4</li>
<li>Modified Quicksort： always select a central splitter before recursions</li>
</ul>
<p><em><strong>claim</strong></em>: The expected number of iterations needed until we find a central splitter is at most 2.</p>
<blockquote>
<p>找到理想pivot的期望次数为 <strong>2</strong>.</p>
</blockquote>
<ul>
<li>推导：
<ul>
<li>假设我们经过k次尝试找到了理想分割点，每次尝试都是独立的，概率为$\frac{1}{2}$;</li>
<li>设x为需要的寻找次数，那么x的期望为E(x);</li>
<li>根据期望的定义，E(x) = $\sum_{k=1}^\infty \frac{k}{2^k}$ = 2;</li>
</ul>
</li>
</ul>
<p>$O(N\log N)$ 是上述算法的平均时间复杂度，而不是worst case.</p>
<blockquote>
<p>Type j.</p>
</blockquote>
<hr>
<h2 id="parallel-algorithms">Parallel Algorithms</h2>
<h3 id="summattion-problem">summattion problem</h3>
<ul>
<li><strong>input</strong>: A(1)~A(n);</li>
<li><strong>output</strong>: $sum_{i=1}^n A_i$;</li>
</ul>
<p>策略：采用二叉平衡树 binary balanced tree,自底向上求解$B-i$，root就是所求的答案.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> P_i ,  </span><span style="color:#79B8FF">1</span><span style="color:#F97583"> &#x3C;=</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> n  pardo</span><span style="color:#6A737D"> //初始化赋值底层节点</span></span>
<span class="line"><span style="color:#B392F0">   B</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, i) :</span><span style="color:#F97583">=</span><span style="color:#B392F0"> A</span><span style="color:#E1E4E8">( i )</span></span>
<span class="line"><span style="color:#6A737D">//遍历高度(此处的h从底部向上递增)</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> h </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8"> to log n </span></span>
<span class="line"><span style="color:#6A737D">    // n/2^h是第h层的节点数</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> Pi, </span><span style="color:#79B8FF">1</span><span style="color:#F97583"> &#x3C;=</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> n</span><span style="color:#F97583">/</span><span style="color:#E1E4E8">{</span><span style="color:#79B8FF">2</span><span style="color:#F97583">^</span><span style="color:#E1E4E8">h}  pardo</span></span>
<span class="line"><span style="color:#B392F0">        B</span><span style="color:#E1E4E8">(h, i) :</span><span style="color:#F97583">=</span><span style="color:#B392F0"> B</span><span style="color:#E1E4E8">(h</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#FDAEB7;font-style:italic">2i</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">+</span><span style="color:#B392F0"> B</span><span style="color:#E1E4E8">(h</span><span style="color:#F97583">-</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">, </span><span style="color:#FDAEB7;font-style:italic">2i</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8"> pardo</span></span>
<span class="line"><span style="color:#E1E4E8">   output  </span><span style="color:#B392F0">B</span><span style="color:#E1E4E8">(log </span><span style="color:#FFAB70">n</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">)</span><span style="color:#6A737D"> //root</span></span>
<span class="line"></span></code></pre>
<h3 id="prefix-sums">Prefix-Sums</h3>
<ul>
<li><strong>input</strong>: A(1)~A(n);</li>
<li><strong>output</strong>: $\sum_{i=1}^1 A_i , \sum_{i=1}^2 A_i , \dots  \sum_{i=1}^n A_i$;</li>
</ul>
<p>这个问题的输入输出与上一个问题十分相似，我们在上述算法的基础上完成.</p>
<p>策略：</p>
<ul>
<li>先用$\log N$的时间完成上一步的算法，自底向上获得所有的B;</li>
<li>然后从上往下获得每一个节点的属性 <strong>C(h,i)</strong>：
<ul>
<li>h依旧遵循B的高度，即自底向上递增的高度；</li>
<li>i表示第h层的第i个节点；
我们希望从上往下构建完成的时候，叶子层的各个节点包含了前缀和.</li>
</ul>
</li>
</ul>
<p>具体的赋值方法参见prodrafts.在此用语言抽象：</p>
<ul>
<li>每层的第一个节点，C = B ;</li>
<li>每层偶数个节点，用父节点的C赋值；</li>
<li>其余节点：父节点的C + 当前节点的B.</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#6A737D">//自底向上构造B</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> Pi , </span><span style="color:#79B8FF">1</span><span style="color:#F97583"> &#x3C;=</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> n pardo</span></span>
<span class="line"><span style="color:#B392F0">  B</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, i) :</span><span style="color:#F97583">=</span><span style="color:#B392F0"> A</span><span style="color:#E1E4E8">(i)</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> h </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8"> to log n</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8"> i , </span><span style="color:#79B8FF">1</span><span style="color:#F97583"> &#x3C;=</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> n</span><span style="color:#F97583">/</span><span style="color:#79B8FF">2</span><span style="color:#F97583">^</span><span style="color:#E1E4E8">h pardo</span></span>
<span class="line"><span style="color:#B392F0">    B</span><span style="color:#E1E4E8">(h, i) :</span><span style="color:#F97583">=</span><span style="color:#B392F0"> B</span><span style="color:#E1E4E8">(h </span><span style="color:#F97583">-</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">, </span><span style="color:#FDAEB7;font-style:italic">2i</span><span style="color:#F97583"> -</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">+</span><span style="color:#B392F0"> B</span><span style="color:#E1E4E8">(h </span><span style="color:#F97583">-</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">, </span><span style="color:#FDAEB7;font-style:italic">2i</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">//自定向下构造C</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> h </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> log n to </span><span style="color:#79B8FF">0</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8"> i even, </span><span style="color:#79B8FF">1</span><span style="color:#F97583"> &#x3C;=</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> n</span><span style="color:#F97583">/</span><span style="color:#79B8FF">2</span><span style="color:#F97583">^</span><span style="color:#E1E4E8">h pardo</span></span>
<span class="line"><span style="color:#B392F0">    C</span><span style="color:#E1E4E8">(h, i) :</span><span style="color:#F97583">=</span><span style="color:#B392F0"> C</span><span style="color:#E1E4E8">(h </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">, i</span><span style="color:#F97583">/</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8"> pardo</span></span>
<span class="line"><span style="color:#B392F0">    C</span><span style="color:#E1E4E8">(h, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">) :</span><span style="color:#F97583">=</span><span style="color:#B392F0"> B</span><span style="color:#E1E4E8">(h, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#F97583">  for</span><span style="color:#E1E4E8"> i odd, </span><span style="color:#79B8FF">3</span><span style="color:#F97583"> &#x3C;=</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> n</span><span style="color:#F97583">/</span><span style="color:#79B8FF">2</span><span style="color:#F97583">^</span><span style="color:#E1E4E8">h pardo</span></span>
<span class="line"><span style="color:#B392F0">    C</span><span style="color:#E1E4E8">(h, i) :</span><span style="color:#F97583">=</span><span style="color:#B392F0"> C</span><span style="color:#E1E4E8">(h </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">, (i </span><span style="color:#F97583">-</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">)</span><span style="color:#F97583">/</span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">+</span><span style="color:#B392F0"> B</span><span style="color:#E1E4E8">(h, i)</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> Pi , </span><span style="color:#79B8FF">1</span><span style="color:#F97583"> &#x3C;=</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> n pardo</span></span>
<span class="line"><span style="color:#E1E4E8">  Output </span><span style="color:#B392F0">C</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">, i)</span></span>
<span class="line"></span></code></pre>
<p>T(n) = O($\log n$); W(n) = O(n).</p>
<h3 id="merge-1">Merge</h3>
<ul>
<li><strong>input</strong>: A(1)~A(n), B(1)~B(m) 且均为递增序列;</li>
<li><strong>output</strong>: C(1)~C(n+m), sorted;</li>
</ul>
<blockquote>
<p>为了方便讨论，假设m,n相等;</p>
</blockquote>
<p><strong>claim</strong>:
Given a solution to the ranking problem, the merging problem can be solved in O(1) time and O(n+m) work.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> Pi , </span><span style="color:#79B8FF">1</span><span style="color:#F97583"> &#x3C;=</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> n  pardo</span></span>
<span class="line"><span style="color:#B392F0">    C</span><span style="color:#E1E4E8">(i </span><span style="color:#F97583">+</span><span style="color:#B392F0"> RANK</span><span style="color:#E1E4E8">(i, B)) :</span><span style="color:#F97583">=</span><span style="color:#B392F0"> A</span><span style="color:#E1E4E8">(i)</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> Pi , </span><span style="color:#79B8FF">1</span><span style="color:#F97583"> &#x3C;=</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> n  pardo</span></span>
<span class="line"><span style="color:#B392F0">    C</span><span style="color:#E1E4E8">(i </span><span style="color:#F97583">+</span><span style="color:#B392F0"> RANK</span><span style="color:#E1E4E8">(i, A)) :</span><span style="color:#F97583">=</span><span style="color:#B392F0"> B</span><span style="color:#E1E4E8">(i)</span></span>
<span class="line"></span></code></pre>
<p><strong>思路</strong>：将merge转化为rank.</p>
<ul>
<li>BST方法：</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> Pi , </span><span style="color:#79B8FF">1</span><span style="color:#F97583"> &#x3C;=</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> n  pardo</span></span>
<span class="line"><span style="color:#B392F0">    RANK</span><span style="color:#E1E4E8">(i, B) :</span><span style="color:#F97583">=</span><span style="color:#B392F0"> BS</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">A</span><span style="color:#E1E4E8">(i), B)</span></span>
<span class="line"><span style="color:#B392F0">    RANK</span><span style="color:#E1E4E8">(i, A) :</span><span style="color:#F97583">=</span><span style="color:#B392F0"> BS</span><span style="color:#E1E4E8">(</span><span style="color:#B392F0">B</span><span style="color:#E1E4E8">(i), A)</span></span>
<span class="line"></span></code></pre>
<blockquote>
<p>T(n) = O($\log n$), W(n) = O($n\log n$);</p>
</blockquote>
<ul>
<li>串行方法:</li>
</ul>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#E1E4E8">i </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> j </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; </span></span>
<span class="line"><span style="color:#F97583">while</span><span style="color:#E1E4E8"> ( i </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> n </span><span style="color:#F97583">||</span><span style="color:#E1E4E8"> j </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> m ) {</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> ( </span><span style="color:#B392F0">A</span><span style="color:#E1E4E8">(i</span><span style="color:#F97583">+</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">&#x3C;</span><span style="color:#B392F0"> B</span><span style="color:#E1E4E8">(j</span><span style="color:#F97583">+</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">) )</span></span>
<span class="line"><span style="color:#B392F0">        RANK</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">i, B) </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> j;</span></span>
<span class="line"><span style="color:#F97583">    else</span><span style="color:#B392F0"> RANK</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">j, A) </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> i;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span>
<span class="line"></span></code></pre>
<blockquote>
<p>T(n) = W(n) = O(n+m);</p>
</blockquote>
<p>但是上述的两种方法依旧不是我们预期的，我们将通过并行的方法来优化.</p>
<h4 id="parallel-ranking">Parallel Ranking</h4>
<ul>
<li><strong>p</strong>：分区的个数</li>
<li>思路：
<ul>
<li>令 p = $\frac{n}{\log n}$，这是分区的个数；</li>
<li>对于p个分区，共有2p个，且size均为$\log n$；</li>
<li>此时我们调用处理器并行地用朴素的串行算法计算（T与W均为size）；</li>
<li>最终结果: <strong>T = O(log n), W = O(n)</strong>.</li>
</ul>
</li>
</ul>
<h3 id="maximum-finding">Maximum Finding</h3>
<ul>
<li>朴素方法：在summation problem的基础上用<code>max</code>来代替<code>+</code>
<ul>
<li>T = log n, W = n;</li>
</ul>
</li>
</ul>
<h4 id="compare-all-pairs">Compare all pairs</h4>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="c"><code><span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> Pi , </span><span style="color:#79B8FF">1</span><span style="color:#F97583"> &#x3C;=</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> n  pardo</span></span>
<span class="line"><span style="color:#B392F0">    B</span><span style="color:#E1E4E8">(i) :</span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> i and j, </span><span style="color:#79B8FF">1</span><span style="color:#F97583"> &#x3C;=</span><span style="color:#E1E4E8"> i, j </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> n  pardo</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#E1E4E8"> ( (</span><span style="color:#B392F0">A</span><span style="color:#E1E4E8">(i) </span><span style="color:#F97583">&#x3C;</span><span style="color:#B392F0"> A</span><span style="color:#E1E4E8">(j)) </span><span style="color:#F97583">||</span><span style="color:#E1E4E8"> ((</span><span style="color:#B392F0">A</span><span style="color:#E1E4E8">(i) </span><span style="color:#F97583">=</span><span style="color:#B392F0"> A</span><span style="color:#E1E4E8">(j)) </span><span style="color:#F97583">&#x26;&#x26;</span><span style="color:#E1E4E8"> (i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> j)) )</span></span>
<span class="line"><span style="color:#B392F0">            B</span><span style="color:#E1E4E8">(i) </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span></span>
<span class="line"><span style="color:#F97583">    else</span><span style="color:#B392F0"> B</span><span style="color:#E1E4E8">(j) </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span></span>
<span class="line"><span style="color:#F97583">for</span><span style="color:#E1E4E8"> Pi , </span><span style="color:#79B8FF">1</span><span style="color:#F97583"> &#x3C;=</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">&#x3C;=</span><span style="color:#E1E4E8"> n  pardo</span></span>
<span class="line"><span style="color:#F97583">    if</span><span style="color:#B392F0"> B</span><span style="color:#E1E4E8">(i) </span><span style="color:#F97583">==</span><span style="color:#79B8FF"> 0</span></span>
<span class="line"><span style="color:#B392F0">       A</span><span style="color:#E1E4E8">(i) is a maximum in A</span></span>
<span class="line"></span></code></pre>
<blockquote>
<ol>
<li>初始化辅助数组B为0；</li>
<li>用$O(N^2)$的处理器同时比较，将较小的那个B赋值为1;</li>
<li>调用N个处理器查找B，输出B为0的那个位置，就是最大值.</li>
<li>由于同时读写，处理conflict的策略为：<strong>arbitrary</strong>.</li>
</ol>
</blockquote>
<p>T = 1, W = $O(N^2)$.</p>
<h4 id="doubly-logarithmic-paradigm">Doubly-logarithmic Paradigm</h4>
<p>整体思路：</p>
<ol>
<li>将输入设置为不同的分区，在各自分区内调用处理器采用朴素的方法T=W=size找出最大值，</li>
<li>然后将不同的分区采用compare all pairs的方法合并，找到最大值.</li>
</ol>
<p>分区尺寸为$\sqrt{n}$:</p>
<ul>
<li>T(n) = $O(\log{\log n})$;</li>
<li>W(n) = $O(n\cdot\log{\log n})$;</li>
</ul>
<p>分区尺寸为h = $\log{\log n}$:</p>
<ul>
<li>T(n) = $O(\log{\log n})$;</li>
<li>W(n) = O(n);</li>
</ul>
<h4 id="random-sampling">Random Sampling</h4>
<p>用O(n)的processors可以获得：</p>
<ul>
<li>T = O(1);</li>
<li>W = O(n);</li>
</ul>
<blockquote>
<p>推导详见prodrafts.</p>
</blockquote>
<h2 id="external-sorting">External Sorting</h2>
<h3 id="overview">Overview</h3>
<ul>
<li>内存限制了使用快排等内部排序的size；</li>
</ul>
<p><em><strong>steps:</strong></em></p>
<ol>
<li><strong>Read in</strong>: for k-way merge,将内存划分为2k+2个buffer, 采用2k个input buffer,2个output buffer；
<ol>
<li>output buffer当中，其中一个用来存储内存产生的数据，另一个用于向disk写入的缓冲区.</li>
</ol>
</li>
<li><strong>Initial Sort</strong>: 将连续的序列第一次排序，我们期望获得更长的 <strong>run</strong>;
<ol>
<li>采用 <strong>replacement selection</strong> 的方法；</li>
</ol>
</li>
<li><strong>Merge</strong>: 第一次排序后，我们需要对不同的run进行合并，各个tape的run的长度会影响最终的passes(run合并的循环次数)
<ol>
<li>采用<strong>polyphase merge</strong>的方式，即尽可能构造斐波那契队列的run分配；</li>
<li>对于k-tape,采用的时k-fibonacci序列；</li>
</ol>
</li>
<li><strong>Minimize merge time</strong>: 对于已经构造完毕的队列，我们可以通过 <strong>哈夫曼编码</strong> 的结构来减小成本；
<ol>
<li>即优先merge较短的run，这样可以减少需要merge的次数；</li>
</ol>
</li>
</ol>
<h3 id="补充">补充</h3>
<ul>
<li>k-way merge：
<ul>
<li>number of passes = $1+\lceil \log_k{(N/M)} \rceil$;</li>
<li>需要 <strong>2k</strong> 个tape;</li>
<li>k并非越大越好;</li>
</ul>
</li>
<li>polyphase merge：
<ul>
<li>k-way merge只需要<strong>k+1</strong>个tape；</li>
<li>如果N不是斐波那契数，add dummy runs -> get to the nearsest Fibonacci number;</li>
</ul>
</li>
<li>replacement selection：
<ul>
<li>如果新加入的元素比刚刚提取的最小元素要大，保留其作用；</li>
<li>否则，将其“失效”，或者说存放在另一个小顶堆里等待下一轮的run；</li>
<li>如此得到的run的长度，其均值为2M,M是内存（原来的run的大小）；</li>
</ul>
</li>
<li>哈夫曼编码：
<ul>
<li>每次取用最小的2个run合并（较小的放在左子树），然后放回队列；</li>
<li>如此循环直至队列中不存在2个run；</li>
<li>根据高度 x run可以计算总时间.</li>
</ul>
</li>
</ul>  <div class="bio" data-astro-cid-2jiluk5e> <strong data-astro-cid-2jiluk5e>关于作者</strong> <div class="bio-content" data-astro-cid-2jiluk5e> <img src="/avatar.jpg" alt="待抉" class="avatar" data-astro-cid-2jiluk5e> <div class="bio-text" data-astro-cid-2jiluk5e> <p class="name" data-astro-cid-2jiluk5e>待抉</p> <p class="description" data-astro-cid-2jiluk5e>热爱技术，热爱生活。分享编程经验和个人思考。</p> </div> </div> </div>  </div> <nav class="toc" data-astro-cid-xvrfupwn> <ul id="toc-list" data-astro-cid-xvrfupwn></ul> </nav>   </article> </main> <footer data-astro-cid-sz7xmlte> <div class="footer-content" data-astro-cid-sz7xmlte> <p class="copyright" data-astro-cid-sz7xmlte>&copy; 2024 待抉. All rights reserved.</p> <div class="social-links" data-astro-cid-sz7xmlte> <a href="https://m.webtoo.ls/@astro" target="_blank" data-astro-cid-sz7xmlte> <span class="sr-only" data-astro-cid-sz7xmlte>Follow Astro on Mastodon</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" data-astro-cid-sz7xmlte><path fill="currentColor" d="M11.19 12.195c2.016-.24 3.77-1.475 3.99-2.603.348-1.778.32-4.339.32-4.339 0-3.47-2.286-4.488-2.286-4.488C12.062.238 10.083.017 8.027 0h-.05C5.92.017 3.942.238 2.79.765c0 0-2.285 1.017-2.285 4.488l-.002.662c-.004.64-.007 1.35.011 2.091.083 3.394.626 6.74 3.78 7.57 1.454.383 2.703.463 3.709.408 1.823-.1 2.847-.647 2.847-.647l-.06-1.317s-1.303.41-2.767.36c-1.45-.05-2.98-.156-3.215-1.928a3.614 3.614 0 0 1-.033-.496s1.424.346 3.228.428c1.103.05 2.137-.064 3.188-.189zm1.613-2.47H11.13v-4.08c0-.859-.364-1.295-1.091-1.295-.804 0-1.207.517-1.207 1.541v2.233H7.168V5.89c0-1.024-.403-1.541-1.207-1.541-.727 0-1.091.436-1.091 1.296v4.079H3.197V5.522c0-.859.22-1.541.66-2.046.456-.505 1.052-.764 1.793-.764.856 0 1.504.328 1.933.983L8 4.39l.417-.695c.429-.655 1.077-.983 1.934-.983.74 0 1.336.259 1.791.764.442.505.661 1.187.661 2.046v4.203z" data-astro-cid-sz7xmlte></path></svg> </a> <a href="https://twitter.com/astrodotbuild" target="_blank" data-astro-cid-sz7xmlte> <span class="sr-only" data-astro-cid-sz7xmlte>Follow Astro on Twitter</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" data-astro-cid-sz7xmlte><path fill="currentColor" d="M5.026 15c6.038 0 9.341-5.003 9.341-9.334 0-.14 0-.282-.006-.422A6.685 6.685 0 0 0 16 3.542a6.658 6.658 0 0 1-1.889.518 3.301 3.301 0 0 0 1.447-1.817 6.533 6.533 0 0 1-2.087.793A3.286 3.286 0 0 0 7.875 6.03a9.325 9.325 0 0 1-6.767-3.429 3.289 3.289 0 0 0 1.018 4.382A3.323 3.323 0 0 1 .64 6.575v.045a3.288 3.288 0 0 0 2.632 3.218 3.203 3.203 0 0 1-.865.115 3.23 3.23 0 0 1-.614-.057 3.283 3.283 0 0 0 3.067 2.277A6.588 6.588 0 0 1 .78 13.58a6.32 6.32 0 0 1-.78-.045A9.344 9.344 0 0 0 5.026 15z" data-astro-cid-sz7xmlte></path></svg> </a> <a href="https://github.com/withastro/astro" target="_blank" data-astro-cid-sz7xmlte> <span class="sr-only" data-astro-cid-sz7xmlte>Go to Astro's GitHub repo</span> <svg viewBox="0 0 16 16" aria-hidden="true" width="32" height="32" data-astro-cid-sz7xmlte><path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.012 8.012 0 0 0 16 8c0-4.42-3.58-8-8-8z" data-astro-cid-sz7xmlte></path></svg> </a> </div> </div> </footer>  </body></html>